{"version":3,"sources":["webpack:///../node_modules/@theia/core/src/common/ternary-search-tree.ts","webpack:///../node_modules/@theia/filesystem/src/browser/file-service.ts","webpack:///../node_modules/@theia/filesystem/src/browser/filesystem-preferences.ts","webpack:///../node_modules/@theia/filesystem/src/browser/filesystem-watcher-error-handler.ts","webpack:///../node_modules/@theia/filesystem/src/common/delegating-file-system-provider.ts","webpack:///../node_modules/@theia/filesystem/src/common/files.ts","webpack:///../node_modules/@theia/filesystem/src/common/filesystem-utils.ts","webpack:///../node_modules/@theia/filesystem/src/common/io.ts"],"names":[],"mappings":"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","file":"0.bundle.js","sourcesContent":["/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/base/common/map.ts#L251\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\n/* eslint-disable @typescript-eslint/tslint/config */\n\nimport URI from './uri';\nimport { CharCode } from './char-code';\nimport { compareSubstringIgnoreCase, compare, compareSubstring } from './strings';\n\nexport interface IKeyIterator<K> {\n    reset(key: K): this;\n    next(): this;\n\n    hasNext(): boolean;\n    cmp(a: string): number;\n    value(): string;\n}\n\nexport class PathIterator implements IKeyIterator<string> {\n\n    private _value!: string;\n    private _from!: number;\n    private _to!: number;\n\n    constructor(\n        private readonly _splitOnBackslash: boolean = true,\n        private readonly _caseSensitive: boolean = true\n    ) { }\n\n    reset(key: string): this {\n        this._value = key.replace(/\\\\$|\\/$/, '');\n        this._from = 0;\n        this._to = 0;\n        return this.next();\n    }\n\n    hasNext(): boolean {\n        return this._to < this._value.length;\n    }\n\n    next(): this {\n        // this._data = key.split(/[\\\\/]/).filter(s => !!s);\n        this._from = this._to;\n        let justSeps = true;\n        for (; this._to < this._value.length; this._to++) {\n            const ch = this._value.charCodeAt(this._to);\n            if (ch === CharCode.Slash || this._splitOnBackslash && ch === CharCode.Backslash) {\n                if (justSeps) {\n                    this._from++;\n                } else {\n                    break;\n                }\n            } else {\n                justSeps = false;\n            }\n        }\n        return this;\n    }\n\n    cmp(a: string): number {\n        return this._caseSensitive\n            ? compareSubstring(a, this._value, 0, a.length, this._from, this._to)\n            : compareSubstringIgnoreCase(a, this._value, 0, a.length, this._from, this._to);\n    }\n\n    value(): string {\n        return this._value.substring(this._from, this._to);\n    }\n}\n\nconst enum UriIteratorState {\n    Scheme = 1, Authority = 2, Path = 3, Query = 4, Fragment = 5\n}\n\nexport class UriIterator implements IKeyIterator<URI> {\n\n    private _pathIterator!: PathIterator;\n    private _value!: URI;\n    private _states: UriIteratorState[] = [];\n    private _stateIdx: number = 0;\n\n    constructor(\n        protected readonly caseSensitive: boolean\n    ) { }\n\n    reset(key: URI): this {\n        this._value = key;\n        this._states = [];\n        if (this._value.scheme) {\n            this._states.push(UriIteratorState.Scheme);\n        }\n        if (this._value.authority) {\n            this._states.push(UriIteratorState.Authority);\n        }\n        if (this._value.path) {\n            this._pathIterator = new PathIterator(false, this.caseSensitive);\n            this._pathIterator.reset(key.path.toString());\n            if (this._pathIterator.value()) {\n                this._states.push(UriIteratorState.Path);\n            }\n        }\n        if (this._value.query) {\n            this._states.push(UriIteratorState.Query);\n        }\n        if (this._value.fragment) {\n            this._states.push(UriIteratorState.Fragment);\n        }\n        this._stateIdx = 0;\n        return this;\n    }\n\n    next(): this {\n        if (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext()) {\n            this._pathIterator.next();\n        } else {\n            this._stateIdx += 1;\n        }\n        return this;\n    }\n\n    hasNext(): boolean {\n        return (this._states[this._stateIdx] === UriIteratorState.Path && this._pathIterator.hasNext())\n            || this._stateIdx < this._states.length - 1;\n    }\n\n    cmp(a: string): number {\n        if (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n            return compareSubstringIgnoreCase(a, this._value.scheme);\n        } else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n            return compareSubstringIgnoreCase(a, this._value.authority);\n        } else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n            return this._pathIterator.cmp(a);\n        } else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n            return compare(a, this._value.query);\n        } else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n            return compare(a, this._value.fragment);\n        }\n        throw new Error();\n    }\n\n    value(): string {\n        if (this._states[this._stateIdx] === UriIteratorState.Scheme) {\n            return this._value.scheme;\n        } else if (this._states[this._stateIdx] === UriIteratorState.Authority) {\n            return this._value.authority;\n        } else if (this._states[this._stateIdx] === UriIteratorState.Path) {\n            return this._pathIterator.value();\n        } else if (this._states[this._stateIdx] === UriIteratorState.Query) {\n            return this._value.query;\n        } else if (this._states[this._stateIdx] === UriIteratorState.Fragment) {\n            return this._value.fragment;\n        }\n        throw new Error();\n    }\n}\n\nclass TernarySearchTreeNode<K, V> {\n    segment!: string;\n    value: V | undefined;\n    key!: K;\n    left: TernarySearchTreeNode<K, V> | undefined;\n    mid: TernarySearchTreeNode<K, V> | undefined;\n    right: TernarySearchTreeNode<K, V> | undefined;\n\n    isEmpty(): boolean {\n        return !this.left && !this.mid && !this.right && !this.value;\n    }\n}\n\nexport class TernarySearchTree<K, V> {\n\n    static forUris<E>(caseSensitive: boolean): TernarySearchTree<URI, E> {\n        return new TernarySearchTree<URI, E>(new UriIterator(caseSensitive));\n    }\n\n    static forPaths<E>(): TernarySearchTree<string, E> {\n        return new TernarySearchTree<string, E>(new PathIterator());\n    }\n\n    private _iter: IKeyIterator<K>;\n    private _root: TernarySearchTreeNode<K, V> | undefined;\n\n    constructor(segments: IKeyIterator<K>) {\n        this._iter = segments;\n    }\n\n    clear(): void {\n        this._root = undefined;\n    }\n\n    set(key: K, element: V): V | undefined {\n        const iter = this._iter.reset(key);\n        let node: TernarySearchTreeNode<K, V>;\n\n        if (!this._root) {\n            this._root = new TernarySearchTreeNode<K, V>();\n            this._root.segment = iter.value();\n        }\n\n        node = this._root;\n        while (true) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                if (!node.left) {\n                    node.left = new TernarySearchTreeNode<K, V>();\n                    node.left.segment = iter.value();\n                }\n                node = node.left;\n\n            } else if (val < 0) {\n                // right\n                if (!node.right) {\n                    node.right = new TernarySearchTreeNode<K, V>();\n                    node.right.segment = iter.value();\n                }\n                node = node.right;\n\n            } else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                if (!node.mid) {\n                    node.mid = new TernarySearchTreeNode<K, V>();\n                    node.mid.segment = iter.value();\n                }\n                node = node.mid;\n            } else {\n                break;\n            }\n        }\n        const oldElement = node.value;\n        node.value = element;\n        node.key = key;\n        return oldElement;\n    }\n\n    get(key: K): V | undefined {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            } else if (val < 0) {\n                // right\n                node = node.right;\n            } else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            } else {\n                break;\n            }\n        }\n        return node ? node.value : undefined;\n    }\n\n    delete(key: K): void {\n\n        const iter = this._iter.reset(key);\n        const stack: [-1 | 0 | 1, TernarySearchTreeNode<K, V>][] = [];\n        let node = this._root;\n\n        // find and unset node\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                stack.push([1, node]);\n                node = node.left;\n            } else if (val < 0) {\n                // right\n                stack.push([-1, node]);\n                node = node.right;\n            } else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                stack.push([0, node]);\n                node = node.mid;\n            } else {\n                // remove element\n                node.value = undefined;\n\n                // clean up empty nodes\n                while (stack.length > 0 && node.isEmpty()) {\n                    const [dir, parent] = stack.pop()!;\n                    switch (dir) {\n                        case 1: parent.left = undefined; break;\n                        case 0: parent.mid = undefined; break;\n                        case -1: parent.right = undefined; break;\n                    }\n                    node = parent;\n                }\n                break;\n            }\n        }\n    }\n\n    findSubstr(key: K): V | undefined {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        let candidate: V | undefined = undefined;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            } else if (val < 0) {\n                // right\n                node = node.right;\n            } else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                candidate = node.value || candidate;\n                node = node.mid;\n            } else {\n                break;\n            }\n        }\n        return node && node.value || candidate;\n    }\n\n    findSuperstr(key: K): Iterator<V> | undefined {\n        const iter = this._iter.reset(key);\n        let node = this._root;\n        while (node) {\n            const val = iter.cmp(node.segment);\n            if (val > 0) {\n                // left\n                node = node.left;\n            } else if (val < 0) {\n                // right\n                node = node.right;\n            } else if (iter.hasNext()) {\n                // mid\n                iter.next();\n                node = node.mid;\n            } else {\n                // collect\n                if (!node.mid) {\n                    return undefined;\n                } else {\n                    return this._nodeIterator(node.mid);\n                }\n            }\n        }\n        return undefined;\n    }\n\n    private _nodeIterator(node: TernarySearchTreeNode<K, V>): Iterator<V> {\n        let res: { done: false; value: V; };\n        let idx: number;\n        let data: V[];\n        const next = (): IteratorResult<V> => {\n            if (!data) {\n                // lazy till first invocation\n                data = [];\n                idx = 0;\n                this._forEach(node, value => data.push(value));\n            }\n            if (idx >= data.length) {\n                return { done: true, value: undefined };\n            }\n\n            if (!res) {\n                res = { done: false, value: data[idx++] };\n            } else {\n                res.value = data[idx++];\n            }\n            return res;\n        };\n        return { next };\n    }\n\n    forEach(callback: (value: V, index: K) => any) {\n        this._forEach(this._root, callback);\n    }\n\n    private _forEach(node: TernarySearchTreeNode<K, V> | undefined, callback: (value: V, index: K) => any) {\n        if (node) {\n            // left\n            this._forEach(node.left, callback);\n\n            // node\n            if (node.value) {\n                // callback(node.value, this._iter.join(parts));\n                callback(node.value, node.key);\n            }\n            // mid\n            this._forEach(node.mid, callback);\n\n            // right\n            this._forEach(node.right, callback);\n        }\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/fileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/textfile/browser/textFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/textfile/electron-browser/nativeTextFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/workingCopy/common/workingCopyFileService.ts\n// and https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/workbench/services/workingCopy/common/workingCopyFileOperationParticipant.ts\n\n/* eslint-disable max-len */\n/* eslint-disable @typescript-eslint/no-shadow */\n/* eslint-disable no-null/no-null */\n/* eslint-disable @typescript-eslint/tslint/config */\n/* eslint-disable @typescript-eslint/no-explicit-any */\n\nimport { injectable, inject, named, postConstruct } from 'inversify';\nimport URI from '@theia/core/lib/common/uri';\nimport { timeout, Deferred } from '@theia/core/lib/common/promise-util';\nimport { CancellationToken, CancellationTokenSource } from '@theia/core/lib/common/cancellation';\nimport { Disposable, DisposableCollection } from '@theia/core/lib/common/disposable';\nimport { WaitUntilEvent, Emitter, AsyncEmitter } from '@theia/core/lib/common/event';\nimport { ContributionProvider } from '@theia/core/lib/common/contribution-provider';\nimport { TernarySearchTree } from '@theia/core/lib/common/ternary-search-tree';\nimport {\n    ensureFileSystemProviderError, etag, ETAG_DISABLED,\n    FileChangesEvent,\n    FileOperation, FileOperationError,\n    FileOperationEvent, FileOperationResult, FileSystemProviderCapabilities,\n    FileSystemProviderErrorCode, FileType, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, hasReadWriteCapability,\n    CreateFileOptions, FileContent, FileStat, FileStatWithMetadata,\n    FileStreamContent, FileSystemProvider,\n    FileSystemProviderWithFileReadWriteCapability, FileSystemProviderWithOpenReadWriteCloseCapability,\n    ReadFileOptions, ResolveFileOptions, ResolveMetadataFileOptions,\n    Stat, WatchOptions, WriteFileOptions,\n    toFileOperationResult, toFileSystemProviderErrorCode,\n    ResolveFileResult, ResolveFileResultWithMetadata,\n    MoveFileOptions, CopyFileOptions, BaseStatWithMetadata, FileDeleteOptions, FileOperationOptions, hasAccessCapability, hasUpdateCapability,\n    hasFileReadStreamCapability, FileSystemProviderWithFileReadStreamCapability\n} from '../common/files';\nimport { BinaryBuffer, BinaryBufferReadable, BinaryBufferReadableStream, BinaryBufferReadableBufferedStream, BinaryBufferWriteableStream } from '@theia/core/lib/common/buffer';\nimport { ReadableStream, isReadableStream, isReadableBufferedStream, transform, consumeStream, peekStream, peekReadable, Readable } from '@theia/core/lib/common/stream';\nimport { LabelProvider } from '@theia/core/lib/browser/label-provider';\nimport { FileSystemPreferences } from './filesystem-preferences';\nimport { ProgressService } from '@theia/core/lib/common/progress-service';\nimport { DelegatingFileSystemProvider } from '../common/delegating-file-system-provider';\nimport type { TextDocumentContentChangeEvent } from 'vscode-languageserver-protocol';\nimport { EncodingRegistry } from '@theia/core/lib/browser/encoding-registry';\nimport { UTF8, UTF8_with_bom } from '@theia/core/lib/common/encodings';\nimport { EncodingService, ResourceEncoding, DecodeStreamResult } from '@theia/core/lib/common/encoding-service';\nimport { Mutable } from '@theia/core/lib/common/types';\nimport { readFileIntoStream } from '../common/io';\nimport { FileSystemWatcherErrorHandler } from './filesystem-watcher-error-handler';\nimport { FileSystemUtils } from '../common/filesystem-utils';\n\nexport interface FileOperationParticipant {\n\n    /**\n     * Participate in a file operation of a working copy. Allows to\n     * change the working copy before it is being saved to disk.\n     */\n    participate(\n        target: URI,\n        source: URI | undefined,\n        operation: FileOperation,\n        timeout: number,\n        token: CancellationToken\n    ): Promise<void>;\n}\n\nexport interface ReadEncodingOptions {\n\n    /**\n     * The optional encoding parameter allows to specify the desired encoding when resolving\n     * the contents of the file.\n     */\n    encoding?: string;\n\n    /**\n     * The optional guessEncoding parameter allows to guess encoding from content of the file.\n     */\n    autoGuessEncoding?: boolean;\n}\n\nexport interface WriteEncodingOptions {\n\n    /**\n     * The encoding to use when updating a file.\n     */\n    encoding?: string;\n\n    /**\n     * If set to true, will enforce the selected encoding and not perform any detection using BOMs.\n     */\n    overwriteEncoding?: boolean;\n}\n\nexport interface ReadTextFileOptions extends ReadEncodingOptions, ReadFileOptions {\n    /**\n     * The optional acceptTextOnly parameter allows to fail this request early if the file\n     * contents are not textual.\n     */\n    acceptTextOnly?: boolean;\n}\n\ninterface BaseTextFileContent extends BaseStatWithMetadata {\n\n    /**\n     * The encoding of the content if known.\n     */\n    encoding: string;\n}\n\nexport interface TextFileContent extends BaseTextFileContent {\n\n    /**\n     * The content of a text file.\n     */\n    value: string;\n}\n\nexport interface TextFileStreamContent extends BaseTextFileContent {\n\n    /**\n     * The line grouped content of a text file.\n     */\n    value: ReadableStream<string>;\n}\n\nexport interface CreateTextFileOptions extends WriteEncodingOptions, CreateFileOptions { }\n\nexport interface WriteTextFileOptions extends WriteEncodingOptions, WriteFileOptions { }\n\nexport interface UpdateTextFileOptions extends WriteEncodingOptions, WriteFileOptions {\n    readEncoding: string\n}\n\nexport interface UserFileOperationEvent extends WaitUntilEvent {\n\n    /**\n     * An identifier to correlate the operation through the\n     * different event types (before, after, error).\n     */\n    readonly correlationId: number;\n\n    /**\n     * The file operation that is taking place.\n     */\n    readonly operation: FileOperation;\n\n    /**\n     * The resource the event is about.\n     */\n    readonly target: URI;\n\n    /**\n     * A property that is defined for move operations.\n     */\n    readonly source?: URI;\n}\n\nexport const FileServiceContribution = Symbol('FileServiceContribution');\n\n/**\n * A {@link FileServiceContribution} can be used to add custom {@link FileSystemProvider}s.\n * For this, the contribution has to listen to the {@link FileSystemProviderActivationEvent} and register\n * the custom {@link FileSystemProvider}s according to the scheme when this event is fired.\n *\n * ### Example usage\n * ```ts\n * export class MyFileServiceContribution implements FileServiceContribution {\n *     registerFileSystemProviders(service: FileService): void {\n *         service.onWillActivateFileSystemProvider(event => {\n *             if (event.scheme === 'mySyncProviderScheme') {\n *                 service.registerProvider('mySyncProviderScheme', this.mySyncProvider);\n *             }\n *             if (event.scheme === 'myAsyncProviderScheme') {\n *                 event.waitUntil((async () => {\n *                     const myAsyncProvider = await this.createAsyncProvider();\n *                     service.registerProvider('myAsyncProviderScheme', myAsyncProvider);\n *                 })());\n *             }\n *         });\n *\n *     }\n *```\n */\nexport interface FileServiceContribution {\n    /**\n     * Register custom file system providers for the given {@link FileService}.\n     * @param service The file service for which the providers should be registered.\n     */\n    registerFileSystemProviders(service: FileService): void;\n}\n\n/**\n * Represents the `FileSystemProviderRegistration` event.\n * This event is fired by the {@link FileService} if a {@link FileSystemProvider} is\n * registered to or unregistered from the service.\n */\nexport interface FileSystemProviderRegistrationEvent {\n    /** `True` if a new provider has been registered, `false` if a provider has been unregistered. */\n    added: boolean;\n    /** The (uri) scheme for which the provider was (previously) registered */\n    scheme: string;\n    /** The affected file system provider for which this event was fired. */\n    provider?: FileSystemProvider;\n}\n\n/**\n * Represents the `FileSystemProviderCapabilitiesChange` event.\n * This event is fired by the {@link FileService} if the capabilities of one of its managed\n * {@link FileSystemProvider}s have changed.\n */\nexport interface FileSystemProviderCapabilitiesChangeEvent {\n    /** The affected file system provider for which this event was fired. */\n    provider: FileSystemProvider;\n    /** The (uri) scheme for which the provider is registered */\n    scheme: string;\n}\n\n/**\n * Represents the `FileSystemProviderActivation` event.\n * This event is fired by the {@link FileService} if it wants to activate the\n * {@link FileSystemProvider} for a specific scheme.\n */\nexport interface FileSystemProviderActivationEvent extends WaitUntilEvent {\n    /** The (uri) scheme for which the provider should be activated */\n    scheme: string;\n}\n\nexport const enum TextFileOperationResult {\n    FILE_IS_BINARY\n}\n\nexport class TextFileOperationError extends FileOperationError {\n\n    constructor(\n        message: string,\n        public textFileOperationResult: TextFileOperationResult,\n        public options?: ReadTextFileOptions & WriteTextFileOptions\n    ) {\n        super(message, FileOperationResult.FILE_OTHER_ERROR);\n        Object.setPrototypeOf(this, TextFileOperationError.prototype);\n    }\n\n}\n\n/**\n * The {@link FileService} is the common facade responsible for all interactions with file systems.\n * It manages all registered {@link FileSystemProvider}s and\n *  forwards calls to the responsible {@link FileSystemProvider}, determined by the scheme.\n * For additional documentation regarding the provided functions see also {@link FileSystemProvider}.\n */\n@injectable()\nexport class FileService {\n\n    private readonly BUFFER_SIZE = 64 * 1024;\n\n    @inject(LabelProvider)\n    protected readonly labelProvider: LabelProvider;\n\n    @inject(FileSystemPreferences)\n    protected readonly preferences: FileSystemPreferences;\n\n    @inject(ProgressService)\n    protected readonly progressService: ProgressService;\n\n    @inject(EncodingRegistry)\n    protected readonly encodingRegistry: EncodingRegistry;\n\n    @inject(EncodingService)\n    protected readonly encodingService: EncodingService;\n\n    @inject(ContributionProvider) @named(FileServiceContribution)\n    protected readonly contributions: ContributionProvider<FileServiceContribution>;\n\n    @inject(FileSystemWatcherErrorHandler)\n    protected readonly watcherErrorHandler: FileSystemWatcherErrorHandler;\n\n    @postConstruct()\n    protected init(): void {\n        for (const contribution of this.contributions.getContributions()) {\n            contribution.registerFileSystemProviders(this);\n        }\n    }\n\n    // #region Events\n\n    private correlationIds = 0;\n\n    private readonly onWillRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is being performed.\n     * This event is triggered by user gestures.\n     */\n    readonly onWillRunUserOperation = this.onWillRunUserOperationEmitter.event;\n\n    private readonly onDidFailUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is failed.\n     * This event is triggered by user gestures.\n     */\n    readonly onDidFailUserOperation = this.onDidFailUserOperationEmitter.event;\n\n    private readonly onDidRunUserOperationEmitter = new AsyncEmitter<UserFileOperationEvent>();\n    /**\n     * An event that is emitted when file operation is finished.\n     * This event is triggered by user gestures.\n     */\n    readonly onDidRunUserOperation = this.onDidRunUserOperationEmitter.event;\n\n    // #endregion\n\n    // #region File System Provider\n\n    private onDidChangeFileSystemProviderRegistrationsEmitter = new Emitter<FileSystemProviderRegistrationEvent>();\n    readonly onDidChangeFileSystemProviderRegistrations = this.onDidChangeFileSystemProviderRegistrationsEmitter.event;\n\n    private onWillActivateFileSystemProviderEmitter = new Emitter<FileSystemProviderActivationEvent>();\n    /**\n     * See `FileServiceContribution.registerProviders`.\n     */\n    readonly onWillActivateFileSystemProvider = this.onWillActivateFileSystemProviderEmitter.event;\n\n    private onDidChangeFileSystemProviderCapabilitiesEmitter = new Emitter<FileSystemProviderCapabilitiesChangeEvent>();\n    readonly onDidChangeFileSystemProviderCapabilities = this.onDidChangeFileSystemProviderCapabilitiesEmitter.event;\n\n    private readonly providers = new Map<string, FileSystemProvider>();\n    private readonly activations = new Map<string, Promise<FileSystemProvider>>();\n\n    /**\n     * Registers a new {@link FileSystemProvider} for the given scheme.\n     * @param scheme The (uri) scheme for which the provider should be registered.\n     * @param provider The file system provider that should be registered.\n     *\n     * @returns A `Disposable` that can be invoked to unregister the given provider.\n     */\n    registerProvider(scheme: string, provider: FileSystemProvider): Disposable {\n        if (this.providers.has(scheme)) {\n            throw new Error(`A filesystem provider for the scheme '${scheme}' is already registered.`);\n        }\n\n        this.providers.set(scheme, provider);\n        this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({ added: true, scheme, provider });\n\n        const providerDisposables = new DisposableCollection();\n        providerDisposables.push(provider.onDidChangeFile(changes => this.onDidFilesChangeEmitter.fire(new FileChangesEvent(changes))));\n        providerDisposables.push(provider.onFileWatchError(() => this.handleFileWatchError()));\n        providerDisposables.push(provider.onDidChangeCapabilities(() => this.onDidChangeFileSystemProviderCapabilitiesEmitter.fire({ provider, scheme })));\n\n        return Disposable.create(() => {\n            this.onDidChangeFileSystemProviderRegistrationsEmitter.fire({ added: false, scheme, provider });\n            this.providers.delete(scheme);\n\n            providerDisposables.dispose();\n        });\n    }\n\n    /**\n     * Try to activate the registered provider for the given scheme\n     * @param scheme  The uri scheme for which the responsible provider should be activated.\n     *\n     * @returns A promise of the activated file system provider. Only resolves if a provider is available for this scheme, gets rejected otherwise.\n     */\n    async activateProvider(scheme: string): Promise<FileSystemProvider> {\n        let provider = this.providers.get(scheme);\n        if (provider) {\n            return provider;\n        }\n        let activation = this.activations.get(scheme);\n        if (!activation) {\n            const deferredActivation = new Deferred<FileSystemProvider>();\n            this.activations.set(scheme, activation = deferredActivation.promise);\n            WaitUntilEvent.fire(this.onWillActivateFileSystemProviderEmitter, { scheme }).then(() => {\n                provider = this.providers.get(scheme);\n                if (!provider) {\n                    const error = new Error();\n                    error.name = 'ENOPRO';\n                    error.message = `No file system provider found for scheme ${scheme}`;\n                    throw error;\n                } else {\n                    deferredActivation.resolve(provider);\n                }\n            }).catch(e => deferredActivation.reject(e));\n        }\n        return activation;\n    }\n\n    /**\n     * Tests if the service (i.e. any of its registered {@link FileSystemProvider}s) can handle the given resource.\n     * @param resource `URI` of the resource to test.\n     *\n     * @returns `true` if the resource can be handled, `false` otherwise.\n     */\n    canHandleResource(resource: URI): boolean {\n        return this.providers.has(resource.scheme);\n    }\n\n    /**\n     * Tests if the service (i.e the {@link FileSystemProvider} registered for the given uri scheme) provides the given capability.\n     * @param resource `URI` of the resource to test.\n     * @param capability The required capability.\n     *\n     * @returns `true` if the resource can be handled and the required capability can be provided.\n     */\n    hasCapability(resource: URI, capability: FileSystemProviderCapabilities): boolean {\n        const provider = this.providers.get(resource.scheme);\n\n        return !!(provider && (provider.capabilities & capability));\n    }\n\n    protected async withProvider(resource: URI): Promise<FileSystemProvider> {\n        // Assert path is absolute\n        if (!resource.path.isAbsolute) {\n            throw new FileOperationError(`Unable to resolve filesystem provider with relative file path ${this.resourceForError(resource)}`, FileOperationResult.FILE_INVALID_PATH);\n        }\n\n        return this.activateProvider(resource.scheme);\n    }\n\n    private async withReadProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\n        const provider = await this.withProvider(resource);\n\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n            return provider;\n        }\n\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite, FileReadStream nor FileOpenReadWriteClose capability which is needed for the read operation.`);\n    }\n\n    private async withWriteProvider(resource: URI): Promise<FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability> {\n        const provider = await this.withProvider(resource);\n        if (hasOpenReadWriteCloseCapability(provider) || hasReadWriteCapability(provider)) {\n            return provider;\n        }\n\n        throw new Error(`Filesystem provider for scheme '${resource.scheme}' neither has FileReadWrite nor FileOpenReadWriteClose capability which is needed for the write operation.`);\n    }\n\n    // #endregion\n\n    private onDidRunOperationEmitter = new Emitter<FileOperationEvent>();\n    /**\n     * An event that is emitted when operation is finished.\n     * This event is triggered by user gestures and programmatically.\n     */\n    readonly onDidRunOperation = this.onDidRunOperationEmitter.event;\n\n    /**\n     * Try to resolve file information and metadata for the given resource.\n     * @param resource `URI` of the resource that should be resolved.\n     * @param options  Options to customize the resolvement process.\n     *\n     * @return A promise that resolves if the resource could be successfully resolved.\n     */\n    resolve(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\n    resolve(resource: URI, options?: ResolveFileOptions | undefined): Promise<FileStat>;\n    async resolve(resource: any, options?: any) {\n        try {\n            return await this.doResolveFile(resource, options);\n        } catch (error) {\n\n            // Specially handle file not found case as file operation result\n            if (toFileSystemProviderErrorCode(error) === FileSystemProviderErrorCode.FileNotFound) {\n                throw new FileOperationError(`Unable to resolve non-existing file '${this.resourceForError(resource)}'`, FileOperationResult.FILE_NOT_FOUND);\n            }\n\n            // Bubble up any other error as is\n            throw ensureFileSystemProviderError(error);\n        }\n    }\n\n    private async doResolveFile(resource: URI, options: ResolveMetadataFileOptions): Promise<FileStatWithMetadata>;\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat>;\n    private async doResolveFile(resource: URI, options?: ResolveFileOptions): Promise<FileStat> {\n        const provider = await this.withProvider(resource);\n\n        const resolveTo = options?.resolveTo;\n        const resolveSingleChildDescendants = options?.resolveSingleChildDescendants;\n        const resolveMetadata = options?.resolveMetadata;\n\n        const stat = await provider.stat(resource);\n\n        let trie: TernarySearchTree<URI, boolean> | undefined;\n\n        return this.toFileStat(provider, resource, stat, undefined, !!resolveMetadata, (stat, siblings) => {\n\n            // lazy trie to check for recursive resolving\n            if (!trie) {\n                trie = TernarySearchTree.forUris<true>(!!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive));\n                trie.set(resource, true);\n                if (Array.isArray(resolveTo) && resolveTo.length) {\n                    resolveTo.forEach(uri => trie!.set(uri, true));\n                }\n            }\n\n            // check for recursive resolving\n            if (Boolean(trie.findSuperstr(stat.resource) || trie.get(stat.resource))) {\n                return true;\n            }\n\n            // check for resolving single child folders\n            if (stat.isDirectory && resolveSingleChildDescendants) {\n                return siblings === 1;\n            }\n\n            return false;\n        });\n    }\n\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat>;\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat, siblings: number | undefined, resolveMetadata: true, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStatWithMetadata>;\n    private async toFileStat(provider: FileSystemProvider, resource: URI, stat: Stat | { type: FileType } & Partial<Stat>, siblings: number | undefined, resolveMetadata: boolean, recurse: (stat: FileStat, siblings?: number) => boolean): Promise<FileStat> {\n        const fileStat = FileStat.fromStat(resource, stat);\n\n        // check to recurse for directories\n        if (fileStat.isDirectory && recurse(fileStat, siblings)) {\n            try {\n                const entries = await provider.readdir(resource);\n                const resolvedEntries = await Promise.all(entries.map(async ([name, type]) => {\n                    try {\n                        const childResource = resource.resolve(name);\n                        const childStat = resolveMetadata ? await provider.stat(childResource) : { type };\n\n                        return await this.toFileStat(provider, childResource, childStat, entries.length, resolveMetadata, recurse);\n                    } catch (error) {\n                        console.trace(error);\n\n                        return null; // can happen e.g. due to permission errors\n                    }\n                }));\n\n                // make sure to get rid of null values that signal a failure to resolve a particular entry\n                fileStat.children = resolvedEntries.filter(e => !!e) as FileStat[];\n            } catch (error) {\n                console.trace(error);\n\n                fileStat.children = []; // gracefully handle errors, we may not have permissions to read\n            }\n\n            return fileStat;\n        }\n\n        return fileStat;\n    }\n\n    /**\n     * Try to resolve file information and metadata for all given resource.\n     * @param toResolve An array of all the resources (and corresponding resolvement options) that should be resolved.\n     *\n     * @returns A promise of all resolved resources. The promise is not rejected if any of the given resources cannot be resolved.\n     * Instead this is reflected with the `success` flag of the corresponding {@link ResolveFileResult}.\n     */\n    async resolveAll(toResolve: { resource: URI, options?: ResolveFileOptions }[]): Promise<ResolveFileResult[]>;\n    async resolveAll(toResolve: { resource: URI, options: ResolveMetadataFileOptions }[]): Promise<ResolveFileResultWithMetadata[]>;\n    async resolveAll(toResolve: { resource: URI; options?: ResolveFileOptions; }[]): Promise<ResolveFileResult[]> {\n        return Promise.all(toResolve.map(async entry => {\n            try {\n                return { stat: await this.doResolveFile(entry.resource, entry.options), success: true };\n            } catch (error) {\n                console.trace(error);\n\n                return { stat: undefined, success: false };\n            }\n        }));\n    }\n\n    /**\n     * Tests if the given resource exists in the filesystem.\n     * @param resource `URI` of the resource which should be tested.\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\n     *\n     * @returns A promise that resolves to `true` if the resource exists.\n     */\n    async exists(resource: URI): Promise<boolean> {\n        const provider = await this.withProvider(resource);\n\n        try {\n            const stat = await provider.stat(resource);\n\n            return !!stat;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Tests a user's permissions for the given resource.\n     */\n    async access(resource: URI, mode?: number): Promise<boolean> {\n        const provider = await this.withProvider(resource);\n\n        if (!hasAccessCapability(provider)) {\n            return false;\n        }\n        try {\n            await provider.access(resource, mode);\n            return true;\n        } catch (error) {\n            return false;\n        }\n    }\n\n    /**\n     * Resolves the fs path of the given URI.\n     *\n     * USE WITH CAUTION: You should always prefer URIs to paths if possible, as they are\n     * portable and platform independent. Paths should only be used in cases you directly\n     * interact with the OS, e.g. when running a command on the shell.\n     *\n     * If you need to display human readable simple or long names then use `LabelProvider` instead.\n     * @param resource `URI` of the resource that should be resolved.\n     * @throws Will throw an error if no {@link FileSystemProvider} is registered for the given resource.\n     *\n     * @returns A promise of the resolved fs path.\n     */\n    async fsPath(resource: URI): Promise<string> {\n        const provider = await this.withProvider(resource);\n\n        if (!hasAccessCapability(provider)) {\n            return resource.path.toString();\n        }\n        return provider.fsPath(resource);\n    }\n\n    // #region Text File Reading/Writing\n\n    async create(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doCreate(resource, value, options);\n        }\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.CREATE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.CREATE, target: resource };\n        await this.onWillRunUserOperationEmitter.fire(event);\n\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doCreate(resource, value, options);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n\n        return stat;\n    }\n\n    protected async doCreate(resource: URI, value?: string | Readable<string>, options?: CreateTextFileOptions): Promise<FileStatWithMetadata> {\n        const encoding = await this.getWriteEncoding(resource, options);\n        const encoded = await this.encodingService.encodeStream(value, encoding);\n        return this.createFile(resource, encoded, options);\n    }\n\n    async write(resource: URI, value: string | Readable<string>, options?: WriteTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\n        const encoding = await this.getWriteEncoding(resource, options);\n        const encoded = await this.encodingService.encodeStream(value, encoding);\n        return Object.assign(await this.writeFile(resource, encoded, options), { encoding: encoding.encoding });\n    }\n\n    async read(resource: URI, options?: ReadTextFileOptions): Promise<TextFileContent> {\n        const [bufferStream, decoder] = await this.doRead(resource, {\n            ...options,\n            // optimization: since we know that the caller does not\n            // care about buffering, we indicate this to the reader.\n            // this reduces all the overhead the buffered reading\n            // has (open, read, close) if the provider supports\n            // unbuffered reading.\n            preferUnbuffered: true\n        });\n\n        return {\n            ...bufferStream,\n            encoding: decoder.detected.encoding || UTF8,\n            value: await consumeStream(decoder.stream, strings => strings.join(''))\n        };\n    }\n\n    async readStream(resource: URI, options?: ReadTextFileOptions): Promise<TextFileStreamContent> {\n        const [bufferStream, decoder] = await this.doRead(resource, options);\n\n        return {\n            ...bufferStream,\n            encoding: decoder.detected.encoding || UTF8,\n            value: decoder.stream\n        };\n    }\n\n    private async doRead(resource: URI, options?: ReadTextFileOptions & { preferUnbuffered?: boolean }): Promise<[FileStreamContent, DecodeStreamResult]> {\n        options = this.resolveReadOptions(options);\n\n        // read stream raw (either buffered or unbuffered)\n        let bufferStream: FileStreamContent;\n        if (options?.preferUnbuffered) {\n            const content = await this.readFile(resource, options);\n            bufferStream = {\n                ...content,\n                value: BinaryBufferReadableStream.fromBuffer(content.value)\n            };\n        } else {\n            bufferStream = await this.readFileStream(resource, options);\n        }\n\n        const decoder = await this.encodingService.decodeStream(bufferStream.value, {\n            guessEncoding: options.autoGuessEncoding,\n            overwriteEncoding: detectedEncoding => this.getReadEncoding(resource, options, detectedEncoding)\n        });\n\n        // validate binary\n        if (options?.acceptTextOnly && decoder.detected.seemsBinary) {\n            throw new TextFileOperationError('File seems to be binary and cannot be opened as text', TextFileOperationResult.FILE_IS_BINARY, options);\n        }\n\n        return [bufferStream, decoder];\n    }\n\n    protected resolveReadOptions(options?: ReadTextFileOptions): ReadTextFileOptions {\n        options = {\n            ...options,\n            autoGuessEncoding: typeof options?.autoGuessEncoding === 'boolean' ? options.autoGuessEncoding : this.preferences['files.autoGuessEncoding']\n        };\n        const limits: Mutable<ReadTextFileOptions['limits']> = options.limits = options.limits || {};\n        if (typeof limits.size !== 'number') {\n            limits.size = this.preferences['files.maxFileSizeMB'] * 1024 * 1024;\n        }\n        return options;\n    }\n\n    async update(resource: URI, changes: TextDocumentContentChangeEvent[], options: UpdateTextFileOptions): Promise<FileStatWithMetadata & { encoding: string }> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n        try {\n            await this.validateWriteFile(provider, resource, options);\n            if (hasUpdateCapability(provider)) {\n                const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);;\n                const stat = await provider.updateFile(resource, changes, {\n                    readEncoding: options.readEncoding,\n                    writeEncoding: encoding,\n                    overwriteEncoding: options.overwriteEncoding || false\n                });\n                return Object.assign(FileStat.fromStat(resource, stat), { encoding: stat.encoding });\n            } else {\n                throw new Error('incremental file update is not supported');\n            }\n        } catch (error) {\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\n        }\n    }\n\n    // #endregion\n\n    // #region File Reading/Writing\n\n    async createFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream = BinaryBuffer.fromString(''), options?: CreateFileOptions): Promise<FileStatWithMetadata> {\n\n        // validate overwrite\n        if (!options?.overwrite && await this.exists(resource)) {\n            throw new FileOperationError(`Unable to create file '${this.resourceForError(resource)}' that already exists when overwrite flag is not set`, FileOperationResult.FILE_MODIFIED_SINCE, options);\n        }\n\n        // do write into file (this will create it too)\n        const fileStat = await this.writeFile(resource, bufferOrReadableOrStream);\n\n        // events\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n        return fileStat;\n    }\n\n    async writeFile(resource: URI, bufferOrReadableOrStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream, options?: WriteFileOptions): Promise<FileStatWithMetadata> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(resource), resource);\n\n        try {\n\n            // validate write\n            const stat = await this.validateWriteFile(provider, resource, options);\n\n            // mkdir recursively as needed\n            if (!stat) {\n                await this.mkdirp(provider, resource.parent);\n            }\n\n            // optimization: if the provider has unbuffered write capability and the data\n            // to write is a Readable, we consume up to 3 chunks and try to write the data\n            // unbuffered to reduce the overhead. If the Readable has more data to provide\n            // we continue to write buffered.\n            let bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream;\n            if (hasReadWriteCapability(provider) && !(bufferOrReadableOrStream instanceof BinaryBuffer)) {\n                if (isReadableStream(bufferOrReadableOrStream)) {\n                    const bufferedStream = await peekStream(bufferOrReadableOrStream, 3);\n                    if (bufferedStream.ended) {\n                        bufferOrReadableOrStreamOrBufferedStream = BinaryBuffer.concat(bufferedStream.buffer);\n                    } else {\n                        bufferOrReadableOrStreamOrBufferedStream = bufferedStream;\n                    }\n                } else {\n                    bufferOrReadableOrStreamOrBufferedStream = peekReadable(bufferOrReadableOrStream, data => BinaryBuffer.concat(data), 3);\n                }\n            } else {\n                bufferOrReadableOrStreamOrBufferedStream = bufferOrReadableOrStream;\n            }\n\n            // write file: unbuffered (only if data to write is a buffer, or the provider has no buffered write capability)\n            if (!hasOpenReadWriteCloseCapability(provider) || (hasReadWriteCapability(provider) && bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer)) {\n                await this.doWriteUnbuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream);\n            }\n\n            // write file: buffered\n            else {\n                await this.doWriteBuffered(provider, resource, bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer ? BinaryBufferReadable.fromBuffer(bufferOrReadableOrStreamOrBufferedStream) : bufferOrReadableOrStreamOrBufferedStream);\n            }\n        } catch (error) {\n            this.rethrowAsFileOperationError('Unable to write file', resource, error, options);\n        }\n\n        return this.resolve(resource, { resolveMetadata: true });\n    }\n\n    private async validateWriteFile(provider: FileSystemProvider, resource: URI, options?: WriteFileOptions): Promise<Stat | undefined> {\n        let stat: Stat | undefined = undefined;\n        try {\n            stat = await provider.stat(resource);\n        } catch (error) {\n            return undefined; // file might not exist\n        }\n\n        // file cannot be directory\n        if ((stat.type & FileType.Directory) !== 0) {\n            throw new FileOperationError(`Unable to write file ${this.resourceForError(resource)} that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\n        }\n\n        if (this.modifiedSince(stat, options)) {\n            throw new FileOperationError('File Modified Since', FileOperationResult.FILE_MODIFIED_SINCE, options);\n        }\n\n        return stat;\n    }\n\n    /**\n     * Dirty write prevention: if the file on disk has been changed and does not match our expected\n     * mtime and etag, we bail out to prevent dirty writing.\n     *\n     * First, we check for a mtime that is in the future before we do more checks. The assumption is\n     * that only the mtime is an indicator for a file that has changed on disk.\n     *\n     * Second, if the mtime has advanced, we compare the size of the file on disk with our previous\n     * one using the etag() function. Relying only on the mtime check has proven to produce false\n     * positives due to file system weirdness (especially around remote file systems). As such, the\n     * check for size is a weaker check because it can return a false negative if the file has changed\n     * but to the same length. This is a compromise we take to avoid having to produce checksums of\n     * the file content for comparison which would be much slower to compute.\n     */\n    protected modifiedSince(stat: Stat, options?: WriteFileOptions): boolean {\n        return !!options && typeof options.mtime === 'number' && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED &&\n            typeof stat.mtime === 'number' && typeof stat.size === 'number' &&\n            options.mtime < stat.mtime && options.etag !== etag({ mtime: options.mtime /* not using stat.mtime for a reason, see above */, size: stat.size });\n    }\n\n    async readFile(resource: URI, options?: ReadFileOptions): Promise<FileContent> {\n        const provider = await this.withReadProvider(resource);\n\n        const stream = await this.doReadAsFileStream(provider, resource, {\n            ...options,\n            // optimization: since we know that the caller does not\n            // care about buffering, we indicate this to the reader.\n            // this reduces all the overhead the buffered reading\n            // has (open, read, close) if the provider supports\n            // unbuffered reading.\n            preferUnbuffered: true\n        });\n\n        return {\n            ...stream,\n            value: await BinaryBufferReadableStream.toBuffer(stream.value)\n        };\n    }\n\n    async readFileStream(resource: URI, options?: ReadFileOptions): Promise<FileStreamContent> {\n        const provider = await this.withReadProvider(resource);\n\n        return this.doReadAsFileStream(provider, resource, options);\n    }\n\n    private async doReadAsFileStream(provider: FileSystemProviderWithFileReadWriteCapability | FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, options?: ReadFileOptions & { preferUnbuffered?: boolean }): Promise<FileStreamContent> {\n\n        // install a cancellation token that gets cancelled\n        // when any error occurs. this allows us to resolve\n        // the content of the file while resolving metadata\n        // but still cancel the operation in certain cases.\n        const cancellableSource = new CancellationTokenSource();\n\n        // validate read operation\n        const statPromise = this.validateReadFile(resource, options).then(stat => stat, error => {\n            cancellableSource.cancel();\n\n            throw error;\n        });\n\n        try {\n\n            // if the etag is provided, we await the result of the validation\n            // due to the likelyhood of hitting a NOT_MODIFIED_SINCE result.\n            // otherwise, we let it run in parallel to the file reading for\n            // optimal startup performance.\n            if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED) {\n                await statPromise;\n            }\n\n            let fileStreamPromise: Promise<BinaryBufferReadableStream>;\n\n            // read unbuffered (only if either preferred, or the provider has no buffered read capability)\n            if (!(hasOpenReadWriteCloseCapability(provider) || hasFileReadStreamCapability(provider)) || (hasReadWriteCapability(provider) && options?.preferUnbuffered)) {\n                fileStreamPromise = this.readFileUnbuffered(provider, resource, options);\n            }\n\n            // read streamed (always prefer over primitive buffered read)\n            else if (hasFileReadStreamCapability(provider)) {\n                fileStreamPromise = Promise.resolve(this.readFileStreamed(provider, resource, cancellableSource.token, options));\n            }\n\n            // read buffered\n            else {\n                fileStreamPromise = Promise.resolve(this.readFileBuffered(provider, resource, cancellableSource.token, options));\n            }\n\n            const [fileStat, fileStream] = await Promise.all([statPromise, fileStreamPromise]);\n\n            return {\n                ...fileStat,\n                value: fileStream\n            };\n        } catch (error) {\n            this.rethrowAsFileOperationError('Unable to read file', resource, error, options);\n        }\n    }\n\n    private readFileStreamed(provider: FileSystemProviderWithFileReadStreamCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\n        const fileStream = provider.readFileStream(resource, options, token);\n\n        return transform(fileStream, {\n            data: data => data instanceof BinaryBuffer ? data : BinaryBuffer.wrap(data),\n            error: error => this.asFileOperationError('Unable to read file', resource, error, options)\n        }, data => BinaryBuffer.concat(data));\n    }\n\n    private readFileBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, token: CancellationToken, options: ReadFileOptions = Object.create(null)): BinaryBufferReadableStream {\n        const stream = BinaryBufferWriteableStream.create();\n\n        readFileIntoStream(provider, resource, stream, data => data, {\n            ...options,\n            bufferSize: this.BUFFER_SIZE,\n            errorTransformer: error => this.asFileOperationError('Unable to read file', resource, error, options)\n        }, token);\n\n        return stream;\n    }\n\n    protected rethrowAsFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): never {\n        throw this.asFileOperationError(message, resource, error, options);\n    }\n    protected asFileOperationError(message: string, resource: URI, error: Error, options?: ReadFileOptions & WriteFileOptions & CreateFileOptions): FileOperationError {\n        const fileOperationError = new FileOperationError(`${message} '${this.resourceForError(resource)}' (${ensureFileSystemProviderError(error).toString()})`,\n            toFileOperationResult(error), options);\n        fileOperationError.stack = `${fileOperationError.stack}\\nCaused by: ${error.stack}`;\n        return fileOperationError;\n    }\n\n    private async readFileUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, options?: ReadFileOptions): Promise<BinaryBufferReadableStream> {\n        let buffer = await provider.readFile(resource);\n\n        // respect position option\n        if (options && typeof options.position === 'number') {\n            buffer = buffer.slice(options.position);\n        }\n\n        // respect length option\n        if (options && typeof options.length === 'number') {\n            buffer = buffer.slice(0, options.length);\n        }\n\n        // Throw if file is too large to load\n        this.validateReadFileLimits(resource, buffer.byteLength, options);\n\n        return BinaryBufferReadableStream.fromBuffer(BinaryBuffer.wrap(buffer));\n    }\n\n    private async validateReadFile(resource: URI, options?: ReadFileOptions): Promise<FileStatWithMetadata> {\n        const stat = await this.resolve(resource, { resolveMetadata: true });\n\n        // Throw if resource is a directory\n        if (stat.isDirectory) {\n            throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is actually a directory`, FileOperationResult.FILE_IS_DIRECTORY, options);\n        }\n\n        // Throw if file not modified since (unless disabled)\n        if (options && typeof options.etag === 'string' && options.etag !== ETAG_DISABLED && options.etag === stat.etag) {\n            throw new FileOperationError('File not modified since', FileOperationResult.FILE_NOT_MODIFIED_SINCE, options);\n        }\n\n        // Throw if file is too large to load\n        this.validateReadFileLimits(resource, stat.size, options);\n\n        return stat;\n    }\n\n    private validateReadFileLimits(resource: URI, size: number, options?: ReadFileOptions): void {\n        if (options?.limits) {\n            let tooLargeErrorResult: FileOperationResult | undefined = undefined;\n\n            if (typeof options.limits.memory === 'number' && size > options.limits.memory) {\n                tooLargeErrorResult = FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n            }\n\n            if (typeof options.limits.size === 'number' && size > options.limits.size) {\n                tooLargeErrorResult = FileOperationResult.FILE_TOO_LARGE;\n            }\n\n            if (typeof tooLargeErrorResult === 'number') {\n                throw new FileOperationError(`Unable to read file '${this.resourceForError(resource)}' that is too large to open`, tooLargeErrorResult);\n            }\n        }\n    }\n\n    // #endregion\n\n    // #region Move/Copy/Delete/Create Folder\n\n    async move(source: URI, target: URI, options?: MoveFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doMove(source, target, options.overwrite);\n        }\n        await this.runFileOperationParticipants(target, source, FileOperation.MOVE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.MOVE, target, source };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doMove(source, target, options?.overwrite);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n        return stat;\n    }\n\n    protected async doMove(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\n        const sourceProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(source), source);\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n        // move\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'move', !!overwrite);\n\n        // resolve and send events\n        const fileStat = await this.resolve(target, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'move' ? FileOperation.MOVE : FileOperation.COPY, fileStat));\n\n        return fileStat;\n    }\n\n    async copy(source: URI, target: URI, options?: CopyFileOptions): Promise<FileStatWithMetadata> {\n        if (options?.fromUserGesture === false) {\n            return this.doCopy(source, target, options.overwrite);\n        }\n        await this.runFileOperationParticipants(target, source, FileOperation.COPY);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.COPY, target, source };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        let stat: FileStatWithMetadata;\n        try {\n            stat = await this.doCopy(source, target, options?.overwrite);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n        return stat;\n    }\n\n    protected async doCopy(source: URI, target: URI, overwrite?: boolean): Promise<FileStatWithMetadata> {\n        const sourceProvider = await this.withReadProvider(source);\n        const targetProvider = this.throwIfFileSystemIsReadonly(await this.withWriteProvider(target), target);\n\n        // copy\n        const mode = await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', !!overwrite);\n\n        // resolve and send events\n        const fileStat = await this.resolve(target, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(source, mode === 'copy' ? FileOperation.COPY : FileOperation.MOVE, fileStat));\n\n        return fileStat;\n    }\n\n    private async doMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite: boolean): Promise<'move' | 'copy'> {\n        if (source.toString() === target.toString()) {\n            return mode; // simulate node.js behaviour here and do a no-op if paths match\n        }\n\n        // validation\n        const { exists, isSameResourceWithDifferentPathCase } = await this.doValidateMoveCopy(sourceProvider, source, targetProvider, target, mode, overwrite);\n\n        // if target exists get valid target\n        if (exists && !overwrite) {\n            const parent = await this.resolve(target.parent);\n            const name = target.path.name + '_copy';\n            target = FileSystemUtils.generateUniqueResourceURI(target.parent, parent, name, target.path.ext);\n        }\n\n        // delete as needed (unless target is same resource with different path case)\n        if (exists && !isSameResourceWithDifferentPathCase && overwrite) {\n            await this.delete(target, { recursive: true });\n        }\n\n        // create parent folders\n        await this.mkdirp(targetProvider, target.parent);\n\n        // copy source => target\n        if (mode === 'copy') {\n\n            // same provider with fast copy: leverage copy() functionality\n            if (sourceProvider === targetProvider && hasFileFolderCopyCapability(sourceProvider)) {\n                await sourceProvider.copy(source, target, { overwrite });\n            }\n\n            // when copying via buffer/unbuffered, we have to manually\n            // traverse the source if it is a folder and not a file\n            else {\n                const sourceFile = await this.resolve(source);\n                if (sourceFile.isDirectory) {\n                    await this.doCopyFolder(sourceProvider, sourceFile, targetProvider, target);\n                } else {\n                    await this.doCopyFile(sourceProvider, source, targetProvider, target);\n                }\n            }\n\n            return mode;\n        }\n\n        // move source => target\n        else {\n\n            // same provider: leverage rename() functionality\n            if (sourceProvider === targetProvider) {\n                await sourceProvider.rename(source, target, { overwrite });\n\n                return mode;\n            }\n\n            // across providers: copy to target & delete at source\n            else {\n                await this.doMoveCopy(sourceProvider, source, targetProvider, target, 'copy', overwrite);\n\n                await this.delete(source, { recursive: true });\n\n                return 'copy';\n            }\n        }\n    }\n\n    private async doCopyFile(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI): Promise<void> {\n\n        // copy: source (buffered) => target (buffered)\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n            return this.doPipeBuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (buffered) => target (unbuffered)\n        if (hasOpenReadWriteCloseCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n            return this.doPipeBufferedToUnbuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (unbuffered) => target (buffered)\n        if (hasReadWriteCapability(sourceProvider) && hasOpenReadWriteCloseCapability(targetProvider)) {\n            return this.doPipeUnbufferedToBuffered(sourceProvider, source, targetProvider, target);\n        }\n\n        // copy: source (unbuffered) => target (unbuffered)\n        if (hasReadWriteCapability(sourceProvider) && hasReadWriteCapability(targetProvider)) {\n            return this.doPipeUnbuffered(sourceProvider, source, targetProvider, target);\n        }\n    }\n\n    private async doCopyFolder(sourceProvider: FileSystemProvider, sourceFolder: FileStat, targetProvider: FileSystemProvider, targetFolder: URI): Promise<void> {\n\n        // create folder in target\n        await targetProvider.mkdir(targetFolder);\n\n        // create children in target\n        if (Array.isArray(sourceFolder.children)) {\n            await Promise.all(sourceFolder.children.map(async sourceChild => {\n                const targetChild = targetFolder.resolve(sourceChild.name);\n                if (sourceChild.isDirectory) {\n                    return this.doCopyFolder(sourceProvider, await this.resolve(sourceChild.resource), targetProvider, targetChild);\n                } else {\n                    return this.doCopyFile(sourceProvider, sourceChild.resource, targetProvider, targetChild);\n                }\n            }));\n        }\n    }\n\n    private async doValidateMoveCopy(sourceProvider: FileSystemProvider, source: URI, targetProvider: FileSystemProvider, target: URI, mode: 'move' | 'copy', overwrite?: boolean): Promise<{ exists: boolean, isSameResourceWithDifferentPathCase: boolean }> {\n        let isSameResourceWithDifferentPathCase = false;\n\n        // Check if source is equal or parent to target (requires providers to be the same)\n        if (sourceProvider === targetProvider) {\n            const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n            if (!isPathCaseSensitive) {\n                isSameResourceWithDifferentPathCase = source.toString().toLowerCase() === target.toString().toLowerCase();\n            }\n\n            if (isSameResourceWithDifferentPathCase && mode === 'copy') {\n                throw new Error(`Unable to copy when source '${this.resourceForError(source)}' is same as target '${this.resourceForError(target)}' with different path case on a case insensitive file system`);\n            }\n\n            if (!isSameResourceWithDifferentPathCase && target.isEqualOrParent(source, isPathCaseSensitive)) {\n                throw new Error(`Unable to move/copy when source '${this.resourceForError(source)}' is parent of target '${this.resourceForError(target)}'.`);\n            }\n        }\n\n        // Extra checks if target exists and this is not a rename\n        const exists = await this.exists(target);\n        if (exists && !isSameResourceWithDifferentPathCase) {\n\n            // Special case: if the target is a parent of the source, we cannot delete\n            // it as it would delete the source as well. In this case we have to throw\n            if (sourceProvider === targetProvider) {\n                const isPathCaseSensitive = !!(sourceProvider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n                if (source.isEqualOrParent(target, isPathCaseSensitive)) {\n                    throw new Error(`Unable to move/copy '${this.resourceForError(source)}' into '${this.resourceForError(target)}' since a file would replace the folder it is contained in.`);\n                }\n            }\n        }\n\n        return { exists, isSameResourceWithDifferentPathCase };\n    }\n\n    async createFolder(resource: URI): Promise<FileStatWithMetadata> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n        // mkdir recursively\n        await this.mkdirp(provider, resource);\n\n        // events\n        const fileStat = await this.resolve(resource, { resolveMetadata: true });\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.CREATE, fileStat));\n\n        return fileStat;\n    }\n\n    private async mkdirp(provider: FileSystemProvider, directory: URI): Promise<void> {\n        const directoriesToCreate: string[] = [];\n\n        // mkdir until we reach root\n        while (!directory.path.isRoot) {\n            try {\n                const stat = await provider.stat(directory);\n                if ((stat.type & FileType.Directory) === 0) {\n                    throw new Error(`Unable to create folder ${this.resourceForError(directory)} that already exists but is not a directory`);\n                }\n\n                break; // we have hit a directory that exists -> good\n            } catch (error) {\n\n                // Bubble up any other error that is not file not found\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileNotFound) {\n                    throw error;\n                }\n\n                // Upon error, remember directories that need to be created\n                directoriesToCreate.push(directory.path.base);\n\n                // Continue up\n                directory = directory.parent;\n            }\n        }\n\n        // Create directories as needed\n        for (let i = directoriesToCreate.length - 1; i >= 0; i--) {\n            directory = directory.resolve(directoriesToCreate[i]);\n\n            try {\n                await provider.mkdir(directory);\n            } catch (error) {\n                if (toFileSystemProviderErrorCode(error) !== FileSystemProviderErrorCode.FileExists) {\n                    // For mkdirp() we tolerate that the mkdir() call fails\n                    // in case the folder already exists. This follows node.js\n                    // own implementation of fs.mkdir({ recursive: true }) and\n                    // reduces the chances of race conditions leading to errors\n                    // if multiple calls try to create the same folders\n                    // As such, we only throw an error here if it is other than\n                    // the fact that the file already exists.\n                    // (see also https://github.com/microsoft/vscode/issues/89834)\n                    throw error;\n                }\n            }\n        }\n    }\n\n    async delete(resource: URI, options?: FileOperationOptions & Partial<FileDeleteOptions>): Promise<void> {\n        if (options?.fromUserGesture === false) {\n            return this.doDelete(resource, options);\n        }\n        await this.runFileOperationParticipants(resource, undefined, FileOperation.DELETE);\n\n        const event = { correlationId: this.correlationIds++, operation: FileOperation.DELETE, target: resource };\n        await this.onWillRunUserOperationEmitter.fire(event);\n        try {\n            await this.doDelete(resource, options);\n        } catch (error) {\n            await this.onDidFailUserOperationEmitter.fire(event);\n            throw error;\n        }\n\n        await this.onDidRunUserOperationEmitter.fire(event);\n    }\n\n    protected async doDelete(resource: URI, options?: Partial<FileDeleteOptions>): Promise<void> {\n        const provider = this.throwIfFileSystemIsReadonly(await this.withProvider(resource), resource);\n\n        // Validate trash support\n        const useTrash = !!options?.useTrash;\n        if (useTrash && !(provider.capabilities & FileSystemProviderCapabilities.Trash)) {\n            throw new Error(`Unable to delete file '${this.resourceForError(resource)}' via trash because provider does not support it.`);\n        }\n\n        // Validate delete\n        const exists = await this.exists(resource);\n        if (!exists) {\n            throw new FileOperationError(`Unable to delete non-existing file '${this.resourceForError(resource)}'`, FileOperationResult.FILE_NOT_FOUND);\n        }\n\n        // Validate recursive\n        const recursive = !!options?.recursive;\n        if (!recursive && exists) {\n            const stat = await this.resolve(resource);\n            if (stat.isDirectory && Array.isArray(stat.children) && stat.children.length > 0) {\n                throw new Error(`Unable to delete non-empty folder '${this.resourceForError(resource)}'.`);\n            }\n        }\n\n        // Delete through provider\n        await provider.delete(resource, { recursive, useTrash });\n\n        // Events\n        this.onDidRunOperationEmitter.fire(new FileOperationEvent(resource, FileOperation.DELETE));\n    }\n\n    // #endregion\n\n    // #region File Watching\n\n    private onDidFilesChangeEmitter = new Emitter<FileChangesEvent>();\n    /**\n     * An event that is emitted when files are changed on the disk.\n     */\n    readonly onDidFilesChange = this.onDidFilesChangeEmitter.event;\n\n    private activeWatchers = new Map<string, { disposable: Disposable, count: number }>();\n\n    watch(resource: URI, options: WatchOptions = { recursive: false, excludes: [] }): Disposable {\n        const resolvedOptions: WatchOptions = {\n            ...options,\n            // always ignore temporary upload files\n            excludes: options.excludes.concat('**/theia_upload_*')\n        };\n\n        let watchDisposed = false;\n        let watchDisposable = Disposable.create(() => watchDisposed = true);\n\n        // Watch and wire in disposable which is async but\n        // check if we got disposed meanwhile and forward\n        this.doWatch(resource, resolvedOptions).then(disposable => {\n            if (watchDisposed) {\n                disposable.dispose();\n            } else {\n                watchDisposable = disposable;\n            }\n        }, error => console.error(error));\n\n        return Disposable.create(() => watchDisposable.dispose());\n    }\n\n    async doWatch(resource: URI, options: WatchOptions): Promise<Disposable> {\n        const provider = await this.withProvider(resource);\n        const key = this.toWatchKey(provider, resource, options);\n\n        // Only start watching if we are the first for the given key\n        const watcher = this.activeWatchers.get(key) || { count: 0, disposable: provider.watch(resource, options) };\n        if (!this.activeWatchers.has(key)) {\n            this.activeWatchers.set(key, watcher);\n        }\n\n        // Increment usage counter\n        watcher.count += 1;\n\n        return Disposable.create(() => {\n\n            // Unref\n            watcher.count--;\n\n            // Dispose only when last user is reached\n            if (watcher.count === 0) {\n                watcher.disposable.dispose();\n                this.activeWatchers.delete(key);\n            }\n        });\n    }\n\n    private toWatchKey(provider: FileSystemProvider, resource: URI, options: WatchOptions): string {\n        return [\n            this.toMapKey(provider, resource),  // lowercase path if the provider is case insensitive\n            String(options.recursive),          // use recursive: true | false as part of the key\n            options.excludes.join()             // use excludes as part of the key\n        ].join();\n    }\n\n    // #endregion\n\n    // #region Helpers\n\n    private writeQueues: Map<string, Promise<void>> = new Map();\n\n    private ensureWriteQueue(provider: FileSystemProvider, resource: URI, task: () => Promise<void>): Promise<void> {\n        // ensure to never write to the same resource without finishing\n        // the one write. this ensures a write finishes consistently\n        // (even with error) before another write is done.\n        const queueKey = this.toMapKey(provider, resource);\n        const writeQueue = (this.writeQueues.get(queueKey) || Promise.resolve()).then(task, task);\n        this.writeQueues.set(queueKey, writeQueue);\n        return writeQueue;\n    }\n\n    private toMapKey(provider: FileSystemProvider, resource: URI): string {\n        const isPathCaseSensitive = !!(provider.capabilities & FileSystemProviderCapabilities.PathCaseSensitive);\n\n        return isPathCaseSensitive ? resource.toString() : resource.toString().toLowerCase();\n    }\n\n    private async doWriteBuffered(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, readableOrStreamOrBufferedStream: BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        return this.ensureWriteQueue(provider, resource, async () => {\n\n            // open handle\n            const handle = await provider.open(resource, { create: true });\n\n            // write into handle until all bytes from buffer have been written\n            try {\n                if (isReadableStream(readableOrStreamOrBufferedStream) || isReadableBufferedStream(readableOrStreamOrBufferedStream)) {\n                    await this.doWriteStreamBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n                } else {\n                    await this.doWriteReadableBufferedQueued(provider, handle, readableOrStreamOrBufferedStream);\n                }\n            } catch (error) {\n                throw ensureFileSystemProviderError(error);\n            } finally {\n\n                // close handle always\n                await provider.close(handle);\n            }\n        });\n    }\n\n    private async doWriteStreamBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, streamOrBufferedStream: BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        let posInFile = 0;\n        let stream: BinaryBufferReadableStream;\n\n        // Buffered stream: consume the buffer first by writing\n        // it to the target before reading from the stream.\n        if (isReadableBufferedStream(streamOrBufferedStream)) {\n            if (streamOrBufferedStream.buffer.length > 0) {\n                const chunk = BinaryBuffer.concat(streamOrBufferedStream.buffer);\n                await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n                posInFile += chunk.byteLength;\n            }\n\n            // If the stream has been consumed, return early\n            if (streamOrBufferedStream.ended) {\n                return;\n            }\n\n            stream = streamOrBufferedStream.stream;\n        }\n\n        // Unbuffered stream - just take as is\n        else {\n            stream = streamOrBufferedStream;\n        }\n\n        return new Promise(async (resolve, reject) => {\n\n            stream.on('data', async chunk => {\n\n                // pause stream to perform async write operation\n                stream.pause();\n\n                try {\n                    await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n                } catch (error) {\n                    return reject(error);\n                }\n\n                posInFile += chunk.byteLength;\n\n                // resume stream now that we have successfully written\n                // run this on the next tick to prevent increasing the\n                // execution stack because resume() may call the event\n                // handler again before finishing.\n                setTimeout(() => stream.resume());\n            });\n\n            stream.on('error', error => reject(error));\n            stream.on('end', () => resolve());\n        });\n    }\n\n    private async doWriteReadableBufferedQueued(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, readable: BinaryBufferReadable): Promise<void> {\n        let posInFile = 0;\n\n        let chunk: BinaryBuffer | null;\n        while ((chunk = readable.read()) !== null) {\n            await this.doWriteBuffer(provider, handle, chunk, chunk.byteLength, posInFile, 0);\n\n            posInFile += chunk.byteLength;\n        }\n    }\n\n    private async doWriteBuffer(provider: FileSystemProviderWithOpenReadWriteCloseCapability, handle: number, buffer: BinaryBuffer, length: number, posInFile: number, posInBuffer: number): Promise<void> {\n        let totalBytesWritten = 0;\n        while (totalBytesWritten < length) {\n            const bytesWritten = await provider.write(handle, posInFile + totalBytesWritten, buffer.buffer, posInBuffer + totalBytesWritten, length - totalBytesWritten);\n            totalBytesWritten += bytesWritten;\n        }\n    }\n\n    private async doWriteUnbuffered(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        return this.ensureWriteQueue(provider, resource, () => this.doWriteUnbufferedQueued(provider, resource, bufferOrReadableOrStreamOrBufferedStream));\n    }\n\n    private async doWriteUnbufferedQueued(provider: FileSystemProviderWithFileReadWriteCapability, resource: URI, bufferOrReadableOrStreamOrBufferedStream: BinaryBuffer | BinaryBufferReadable | BinaryBufferReadableStream | BinaryBufferReadableBufferedStream): Promise<void> {\n        let buffer: BinaryBuffer;\n        if (bufferOrReadableOrStreamOrBufferedStream instanceof BinaryBuffer) {\n            buffer = bufferOrReadableOrStreamOrBufferedStream;\n        } else if (isReadableStream(bufferOrReadableOrStreamOrBufferedStream)) {\n            buffer = await BinaryBufferReadableStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        } else if (isReadableBufferedStream(bufferOrReadableOrStreamOrBufferedStream)) {\n            buffer = await BinaryBufferReadableBufferedStream.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        } else {\n            buffer = BinaryBufferReadable.toBuffer(bufferOrReadableOrStreamOrBufferedStream);\n        }\n\n        return provider.writeFile(resource, buffer.buffer, { create: true, overwrite: true });\n    }\n\n    private async doPipeBuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeBufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeBufferedQueued(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        let sourceHandle: number | undefined = undefined;\n        let targetHandle: number | undefined = undefined;\n\n        try {\n\n            // Open handles\n            sourceHandle = await sourceProvider.open(source, { create: false });\n            targetHandle = await targetProvider.open(target, { create: true });\n\n            const buffer = BinaryBuffer.alloc(this.BUFFER_SIZE);\n\n            let posInFile = 0;\n            let posInBuffer = 0;\n            let bytesRead = 0;\n            do {\n                // read from source (sourceHandle) at current position (posInFile) into buffer (buffer) at\n                // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n                bytesRead = await sourceProvider.read(sourceHandle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n                // write into target (targetHandle) at current position (posInFile) from buffer (buffer) at\n                // buffer position (posInBuffer) all bytes we read (bytesRead).\n                await this.doWriteBuffer(targetProvider, targetHandle, buffer, bytesRead, posInFile, posInBuffer);\n\n                posInFile += bytesRead;\n                posInBuffer += bytesRead;\n\n                // when buffer full, fill it again from the beginning\n                if (posInBuffer === buffer.byteLength) {\n                    posInBuffer = 0;\n                }\n            } while (bytesRead > 0);\n        } catch (error) {\n            throw ensureFileSystemProviderError(error);\n        } finally {\n            await Promise.all([\n                typeof sourceHandle === 'number' ? sourceProvider.close(sourceHandle) : Promise.resolve(),\n                typeof targetHandle === 'number' ? targetProvider.close(targetHandle) : Promise.resolve(),\n            ]);\n        }\n    }\n\n    private async doPipeUnbuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeUnbufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n        return targetProvider.writeFile(target, await sourceProvider.readFile(source), { create: true, overwrite: true });\n    }\n\n    private async doPipeUnbufferedToBuffered(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n        return this.ensureWriteQueue(targetProvider, target, () => this.doPipeUnbufferedToBufferedQueued(sourceProvider, source, targetProvider, target));\n    }\n\n    private async doPipeUnbufferedToBufferedQueued(sourceProvider: FileSystemProviderWithFileReadWriteCapability, source: URI, targetProvider: FileSystemProviderWithOpenReadWriteCloseCapability, target: URI): Promise<void> {\n\n        // Open handle\n        const targetHandle = await targetProvider.open(target, { create: true });\n\n        // Read entire buffer from source and write buffered\n        try {\n            const buffer = await sourceProvider.readFile(source);\n            await this.doWriteBuffer(targetProvider, targetHandle, BinaryBuffer.wrap(buffer), buffer.byteLength, 0, 0);\n        } catch (error) {\n            throw ensureFileSystemProviderError(error);\n        } finally {\n            await targetProvider.close(targetHandle);\n        }\n    }\n\n    private async doPipeBufferedToUnbuffered(sourceProvider: FileSystemProviderWithOpenReadWriteCloseCapability, source: URI, targetProvider: FileSystemProviderWithFileReadWriteCapability, target: URI): Promise<void> {\n\n        // Read buffer via stream buffered\n        const buffer = await BinaryBufferReadableStream.toBuffer(this.readFileBuffered(sourceProvider, source, CancellationToken.None));\n\n        // Write buffer into target at once\n        await this.doWriteUnbuffered(targetProvider, target, buffer);\n    }\n\n    protected throwIfFileSystemIsReadonly<T extends FileSystemProvider>(provider: T, resource: URI): T {\n        if (provider.capabilities & FileSystemProviderCapabilities.Readonly) {\n            throw new FileOperationError(`Unable to modify readonly file ${this.resourceForError(resource)}`, FileOperationResult.FILE_PERMISSION_DENIED);\n        }\n\n        return provider;\n    }\n\n    private resourceForError(resource: URI): string {\n        return this.labelProvider.getLongName(resource);\n    }\n\n    // #endregion\n\n    // #region File operation participants\n\n    private readonly participants: FileOperationParticipant[] = [];\n\n    addFileOperationParticipant(participant: FileOperationParticipant): Disposable {\n        this.participants.push(participant);\n\n        return Disposable.create(() => {\n            const index = this.participants.indexOf(participant);\n            if (index > -1) {\n                this.participants.splice(index, 1);\n            }\n        });\n    }\n\n    async runFileOperationParticipants(target: URI, source: URI | undefined, operation: FileOperation): Promise<void> {\n        const participantsTimeout = this.preferences['files.participants.timeout'];\n        if (participantsTimeout <= 0) {\n            return;\n        }\n\n        const cancellationTokenSource = new CancellationTokenSource();\n\n        return this.progressService.withProgress(this.progressLabel(operation), 'window', async () => {\n            for (const participant of this.participants) {\n                if (cancellationTokenSource.token.isCancellationRequested) {\n                    break;\n                }\n\n                try {\n                    const promise = participant.participate(target, source, operation, participantsTimeout, cancellationTokenSource.token);\n                    await Promise.race([\n                        promise,\n                        timeout(participantsTimeout, cancellationTokenSource.token).then(() => cancellationTokenSource.dispose(), () => { /* no-op if cancelled */ })\n                    ]);\n                } catch (err) {\n                    console.warn(err);\n                }\n            }\n        });\n    }\n\n    private progressLabel(operation: FileOperation): string {\n        switch (operation) {\n            case FileOperation.CREATE:\n                return \"Running 'File Create' participants...\";\n            case FileOperation.MOVE:\n                return \"Running 'File Rename' participants...\";\n            case FileOperation.COPY:\n                return \"Running 'File Copy' participants...\";\n            case FileOperation.DELETE:\n                return \"Running 'File Delete' participants...\";\n        }\n    }\n\n    // #endregion\n\n    // #region encoding\n\n    protected async getWriteEncoding(resource: URI, options?: WriteEncodingOptions): Promise<ResourceEncoding> {\n        const encoding = await this.getEncodingForResource(resource, options ? options.encoding : undefined);\n        return this.encodingService.toResourceEncoding(encoding, {\n            overwriteEncoding: options?.overwriteEncoding,\n            read: async length => {\n                const buffer = await BinaryBufferReadableStream.toBuffer((await this.readFileStream(resource, { length })).value);\n                return buffer.buffer;\n            }\n        });\n    }\n\n    protected getReadEncoding(resource: URI, options?: ReadEncodingOptions, detectedEncoding?: string): Promise<string> {\n        let preferredEncoding: string | undefined;\n\n        // Encoding passed in as option\n        if (options?.encoding) {\n            if (detectedEncoding === UTF8_with_bom && options.encoding === UTF8) {\n                preferredEncoding = UTF8_with_bom; // indicate the file has BOM if we are to resolve with UTF 8\n            } else {\n                preferredEncoding = options.encoding; // give passed in encoding highest priority\n            }\n        } else if (detectedEncoding) {\n            preferredEncoding = detectedEncoding;\n        }\n\n        return this.getEncodingForResource(resource, preferredEncoding);\n    }\n\n    protected async getEncodingForResource(resource: URI, preferredEncoding?: string): Promise<string> {\n        resource = await this.toUnderlyingResource(resource);\n        return this.encodingRegistry.getEncodingForResource(resource, preferredEncoding);\n    }\n\n    /**\n     * Converts to an underlying fs provider resource format.\n     *\n     * For example converting `user-storage` resources to `file` resources under a user home:\n     * user-storage:/user/settings.json => file://home/.theia/settings.json\n     */\n    async toUnderlyingResource(resource: URI): Promise<URI> {\n        let provider = await this.withProvider(resource);\n        while (provider instanceof DelegatingFileSystemProvider) {\n            resource = provider.toUnderlyingResource(resource);\n            provider = await this.withProvider(resource);\n        }\n        return resource;\n    }\n\n    // #endregion\n\n    protected handleFileWatchError(): void {\n        this.watcherErrorHandler.handleError();\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2017 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { interfaces } from 'inversify';\nimport {\n    createPreferenceProxy,\n    PreferenceProxy,\n    PreferenceService,\n    PreferenceSchema,\n    PreferenceContribution\n} from '@theia/core/lib/browser/preferences';\nimport { SUPPORTED_ENCODINGS } from '@theia/core/lib/browser/supported-encodings';\nimport { environment } from '@theia/application-package/lib/environment';\n\n// See https://github.com/Microsoft/vscode/issues/30180\nexport const WIN32_MAX_FILE_SIZE_MB = 300; // 300 MB\nexport const GENERAL_MAX_FILE_SIZE_MB = 16 * 1024; // 16 GB\n\nexport const MAX_FILE_SIZE_MB = environment.electron.is() ? process.arch === 'ia32' ? WIN32_MAX_FILE_SIZE_MB : GENERAL_MAX_FILE_SIZE_MB : 32;\n\nexport const filesystemPreferenceSchema: PreferenceSchema = {\n    'type': 'object',\n    'properties': {\n        'files.watcherExclude': {\n            'description': 'List of paths to exclude from the filesystem watcher',\n            'additionalProperties': {\n                'type': 'boolean'\n            },\n            'default': {\n                '**/.git/objects/**': true,\n                '**/.git/subtree-cache/**': true,\n                '**/node_modules/**': true\n            },\n            'scope': 'resource'\n        },\n        'files.exclude': {\n            'type': 'object',\n            'default': { '**/.git': true, '**/.svn': true, '**/.hg': true, '**/CVS': true, '**/.DS_Store': true },\n            'description': 'Configure glob patterns for excluding files and folders.',\n            'scope': 'resource'\n        },\n        'files.enableTrash': {\n            'type': 'boolean',\n            'default': true,\n            'description': 'Moves files/folders to the OS trash (recycle bin on Windows) when deleting. Disabling this will delete files/folders permanently.'\n        },\n        'files.associations': {\n            'type': 'object',\n            'description': 'Configure file associations to languages (e.g. \\\"*.extension\\\": \\\"html\\\"). \\\nThese have precedence over the default associations of the languages installed.'\n        },\n        'files.autoGuessEncoding': {\n            'type': 'boolean',\n            'default': false,\n            'description': 'When enabled, the editor will attempt to guess the character set encoding when opening files. This setting can also be configured per language.',\n            'scope': 'language-overridable',\n            'included': Object.keys(SUPPORTED_ENCODINGS).length > 1\n        },\n        'files.participants.timeout': {\n            type: 'number',\n            default: 5000,\n            markdownDescription: 'Timeout in milliseconds after which file participants for create, rename, and delete are cancelled. Use `0` to disable participants.'\n        },\n        'files.maxFileSizeMB': {\n            type: 'number',\n            default: MAX_FILE_SIZE_MB,\n            markdownDescription: 'Controls the max file size in MB which is possible to open.'\n        }\n    }\n};\n\nexport interface FileSystemConfiguration {\n    'files.watcherExclude': { [globPattern: string]: boolean };\n    'files.exclude': { [key: string]: boolean };\n    'files.enableTrash': boolean;\n    'files.associations': { [filepattern: string]: string };\n    'files.encoding': string;\n    'files.autoGuessEncoding': boolean;\n    'files.participants.timeout': number;\n    'files.maxFileSizeMB': number;\n}\n\nexport const FileSystemPreferences = Symbol('FileSystemPreferences');\nexport type FileSystemPreferences = PreferenceProxy<FileSystemConfiguration>;\n\nexport function createFileSystemPreferences(preferences: PreferenceService): FileSystemPreferences {\n    return createPreferenceProxy(preferences, filesystemPreferenceSchema);\n}\n\nexport function bindFileSystemPreferences(bind: interfaces.Bind): void {\n    bind(FileSystemPreferences).toDynamicValue(ctx => {\n        const preferences = ctx.container.get<PreferenceService>(PreferenceService);\n        return createFileSystemPreferences(preferences);\n    }).inSingletonScope();\n\n    bind(PreferenceContribution).toConstantValue({ schema: filesystemPreferenceSchema });\n}\n","/********************************************************************************\n * Copyright (C) 2020 Arm and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { injectable, inject } from 'inversify';\nimport { environment } from '@theia/application-package/lib/environment';\nimport { MessageService } from '@theia/core';\nimport { WindowService } from '@theia/core/lib/browser/window/window-service';\n\n@injectable()\nexport class FileSystemWatcherErrorHandler {\n\n    @inject(MessageService) protected readonly messageService: MessageService;\n    @inject(WindowService) protected readonly windowService: WindowService;\n\n    protected watchHandlesExhausted: boolean = false;\n\n    protected get instructionsLink(): string {\n        return 'https://code.visualstudio.com/docs/setup/linux#_visual-studio-code-is-unable-to-watch-for-file-changes-in-this-large-workspace-error-enospc';\n    }\n\n    public async handleError(): Promise<void> {\n        if (!this.watchHandlesExhausted) {\n            this.watchHandlesExhausted = true;\n            if (this.isElectron()) {\n                const instructionsAction = 'Instructions';\n                const action = await this.messageService.warn(\n                    'Unable to watch for file changes in this large workspace.  Please follow the instructions link to resolve this issue.',\n                    { timeout: 60000 },\n                    instructionsAction\n                );\n                if (action === instructionsAction) {\n                    this.windowService.openNewWindow(this.instructionsLink, { external: true });\n                }\n            } else {\n                await this.messageService.warn(\n                    'Unable to watch for file changes in this large workspace.  The information you see may not include recent file changes.',\n                    { timeout: 60000 }\n                );\n            }\n        }\n    }\n\n    protected isElectron(): boolean {\n        return environment.electron.is();\n    }\n\n}\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport URI from '@theia/core/lib/common/uri';\nimport { Event, Emitter, CancellationToken } from '@theia/core/lib/common';\nimport { Disposable, DisposableCollection } from '@theia/core/lib/common/disposable';\nimport {\n    FileSystemProvider, FileSystemProviderCapabilities, WatchOptions, FileDeleteOptions, FileOverwriteOptions, FileWriteOptions, FileOpenOptions, FileChange, Stat, FileType,\n    hasReadWriteCapability, hasFileFolderCopyCapability, hasOpenReadWriteCloseCapability, hasAccessCapability, FileUpdateOptions, hasUpdateCapability, FileUpdateResult,\n    FileReadStreamOptions,\n    hasFileReadStreamCapability\n} from './files';\nimport type { TextDocumentContentChangeEvent } from 'vscode-languageserver-protocol';\nimport { ReadableStreamEvents } from '@theia/core/lib/common/stream';\n\nexport class DelegatingFileSystemProvider implements Required<FileSystemProvider>, Disposable {\n\n    private readonly onDidChangeFileEmitter = new Emitter<readonly FileChange[]>();\n    readonly onDidChangeFile = this.onDidChangeFileEmitter.event;\n\n    private readonly onFileWatchErrorEmitter = new Emitter<void>();\n    readonly onFileWatchError = this.onFileWatchErrorEmitter.event;\n\n    constructor(\n        protected readonly delegate: FileSystemProvider,\n        protected readonly options: DelegatingFileSystemProvider.Options,\n        protected readonly toDispose = new DisposableCollection()\n    ) {\n        this.toDispose.push(this.onDidChangeFileEmitter);\n        this.toDispose.push(delegate.onDidChangeFile(changes => this.handleFileChanges(changes)));\n        this.toDispose.push(this.onFileWatchErrorEmitter);\n        this.toDispose.push(delegate.onFileWatchError(changes => this.onFileWatchErrorEmitter.fire()));\n    }\n\n    dispose(): void {\n        this.toDispose.dispose();\n    }\n\n    get capabilities(): FileSystemProviderCapabilities {\n        return this.delegate.capabilities;\n    }\n\n    get onDidChangeCapabilities(): Event<void> {\n        return this.delegate.onDidChangeCapabilities;\n    }\n\n    watch(resource: URI, opts: WatchOptions): Disposable {\n        return this.delegate.watch(this.toUnderlyingResource(resource), opts);\n    }\n\n    stat(resource: URI): Promise<Stat> {\n        return this.delegate.stat(this.toUnderlyingResource(resource));\n    }\n\n    access(resource: URI, mode?: number): Promise<void> {\n        if (hasAccessCapability(this.delegate)) {\n            return this.delegate.access(this.toUnderlyingResource(resource), mode);\n        }\n        throw new Error('not supported');\n    }\n\n    fsPath(resource: URI): Promise<string> {\n        if (hasAccessCapability(this.delegate)) {\n            return this.delegate.fsPath(this.toUnderlyingResource(resource));\n        }\n        throw new Error('not supported');\n    }\n\n    mkdir(resource: URI): Promise<void> {\n        return this.delegate.mkdir(this.toUnderlyingResource(resource));\n    }\n\n    rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n        return this.delegate.rename(this.toUnderlyingResource(from), this.toUnderlyingResource(to), opts);\n    }\n\n    copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void> {\n        if (hasFileFolderCopyCapability(this.delegate)) {\n            return this.delegate.copy(this.toUnderlyingResource(from), this.toUnderlyingResource(to), opts);\n        }\n        throw new Error('not supported');\n    }\n\n    readFile(resource: URI): Promise<Uint8Array> {\n        if (hasReadWriteCapability(this.delegate)) {\n            return this.delegate.readFile(this.toUnderlyingResource(resource));\n        }\n        throw new Error('not supported');\n    }\n\n    readFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array> {\n        if (hasFileReadStreamCapability(this.delegate)) {\n            return this.delegate.readFileStream(this.toUnderlyingResource(resource), opts, token);\n        }\n        throw new Error('not supported');\n    }\n\n    readdir(resource: URI): Promise<[string, FileType][]> {\n        return this.delegate.readdir(this.toUnderlyingResource(resource));\n    }\n\n    writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void> {\n        if (hasReadWriteCapability(this.delegate)) {\n            return this.delegate.writeFile(this.toUnderlyingResource(resource), content, opts);\n        }\n        throw new Error('not supported');\n    }\n\n    open(resource: URI, opts: FileOpenOptions): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.open(this.toUnderlyingResource(resource), opts);\n        }\n        throw new Error('not supported');\n    }\n\n    close(fd: number): Promise<void> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.close(fd);\n        }\n        throw new Error('not supported');\n    }\n\n    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.read(fd, pos, data, offset, length);\n        }\n        throw new Error('not supported');\n    }\n\n    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number> {\n        if (hasOpenReadWriteCloseCapability(this.delegate)) {\n            return this.delegate.write(fd, pos, data, offset, length);\n        }\n        throw new Error('not supported');\n    }\n\n    delete(resource: URI, opts: FileDeleteOptions): Promise<void> {\n        return this.delegate.delete(this.toUnderlyingResource(resource), opts);\n    }\n\n    updateFile(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult> {\n        if (hasUpdateCapability(this.delegate)) {\n            return this.delegate.updateFile(resource, changes, opts);\n        }\n        throw new Error('not supported');\n    }\n\n    protected handleFileChanges(changes: readonly FileChange[]): void {\n        const delegatingChanges: FileChange[] = [];\n        for (const change of changes) {\n            const delegatingResource = this.fromUnderlyingResource(change.resource);\n            if (delegatingResource) {\n                delegatingChanges.push({\n                    resource: delegatingResource,\n                    type: change.type\n                });\n            }\n        }\n        if (delegatingChanges.length) {\n            this.onDidChangeFileEmitter.fire(delegatingChanges);\n        }\n    }\n\n    /**\n     * Converts to an underlying fs provider resource format.\n     *\n     * For example converting `user-storage` resources to `file` resources under a user home:\n     * user-storage:/user/settings.json => file://home/.theia/settings.json\n     */\n    toUnderlyingResource(resource: URI): URI {\n        const underlying = this.options.uriConverter.to(resource);\n        if (!underlying) {\n            throw new Error('invalid resource: ' + resource.toString());\n        }\n        return underlying;\n    }\n\n    /**\n     * Converts from an underlying fs provider resource format.\n     *\n     * For example converting `file` resources under a user home to `user-storage` resource:\n     * - file://home/.theia/settings.json => user-storage:/user/settings.json\n     * - file://documents/some-document.txt => undefined\n     */\n    fromUnderlyingResource(resource: URI): URI | undefined {\n        return this.options.uriConverter.from(resource);\n    }\n\n}\nexport namespace DelegatingFileSystemProvider {\n    export interface Options {\n        uriConverter: URIConverter\n    }\n    export interface URIConverter {\n        /**\n         * Converts to an underlying fs provider resource format.\n         * Returns undefined if the given resource is not valid resource.\n         *\n         * For example converting `user-storage` resources to `file` resources under a user home:\n         * user-storage:/user/settings.json => file://home/.theia/settings.json\n         * user-storage:/settings.json => undefined\n         */\n        to(resource: URI): URI | undefined;\n        /**\n         * Converts from an underlying fs provider resource format.\n         *\n         * For example converting `file` resources under a user home to `user-storage` resource:\n         * - file://home/.theia/settings.json => user-storage:/settings.json\n         * - file://documents/some-document.txt => undefined\n         */\n        from(resource: URI): URI | undefined;\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/files.ts\n\nimport URI from '@theia/core/lib/common/uri';\nimport { Event } from '@theia/core/lib/common/event';\nimport { Disposable as IDisposable } from '@theia/core/lib/common/disposable';\nimport { BinaryBuffer, BinaryBufferReadableStream } from '@theia/core/lib/common/buffer';\nimport type { TextDocumentContentChangeEvent } from 'vscode-languageserver-protocol';\nimport { ReadableStreamEvents } from '@theia/core/lib/common/stream';\nimport { CancellationToken } from '@theia/core/lib/common/cancellation';\n\nexport const enum FileOperation {\n    CREATE,\n    DELETE,\n    MOVE,\n    COPY\n}\n\nexport class FileOperationEvent {\n\n    constructor(resource: URI, operation: FileOperation.DELETE);\n    constructor(resource: URI, operation: FileOperation.CREATE | FileOperation.MOVE | FileOperation.COPY, target: FileStatWithMetadata);\n    constructor(public readonly resource: URI, public readonly operation: FileOperation, public readonly target?: FileStatWithMetadata) { }\n\n    isOperation(operation: FileOperation.DELETE): boolean;\n    isOperation(operation: FileOperation.MOVE | FileOperation.COPY | FileOperation.CREATE): this is { readonly target: FileStatWithMetadata };\n    isOperation(operation: FileOperation): boolean {\n        return this.operation === operation;\n    }\n}\n\n/**\n * Possible changes that can occur to a file.\n */\nexport const enum FileChangeType {\n    UPDATED = 0,\n    ADDED = 1,\n    DELETED = 2\n}\n\n/**\n * Identifies a single change in a file.\n */\nexport interface FileChange {\n\n    /**\n     * The type of change that occurred to the file.\n     */\n    readonly type: FileChangeType;\n\n    /**\n     * The unified resource identifier of the file that changed.\n     */\n    readonly resource: URI;\n}\n\nexport class FileChangesEvent {\n\n    constructor(public readonly changes: readonly FileChange[]) { }\n\n    /**\n     * Returns true if this change event contains the provided file with the given change type (if provided). In case of\n     * type DELETED, this method will also return true if a folder got deleted that is the parent of the\n     * provided file path.\n     */\n    contains(resource: URI, type?: FileChangeType): boolean {\n        if (!resource) {\n            return false;\n        }\n\n        const checkForChangeType = typeof type === 'number';\n\n        return this.changes.some(change => {\n            if (checkForChangeType && change.type !== type) {\n                return false;\n            }\n\n            // For deleted also return true when deleted folder is parent of target path\n            if (change.type === FileChangeType.DELETED) {\n                return resource.isEqualOrParent(change.resource);\n            }\n\n            return resource.toString() === change.resource.toString();\n        });\n    }\n\n    /**\n     * Returns the changes that describe added files.\n     */\n    getAdded(): FileChange[] {\n        return this.getOfType(FileChangeType.ADDED);\n    }\n\n    /**\n     * Returns if this event contains added files.\n     */\n    gotAdded(): boolean {\n        return this.hasType(FileChangeType.ADDED);\n    }\n\n    /**\n     * Returns the changes that describe deleted files.\n     */\n    getDeleted(): FileChange[] {\n        return this.getOfType(FileChangeType.DELETED);\n    }\n\n    /**\n     * Returns if this event contains deleted files.\n     */\n    gotDeleted(): boolean {\n        return this.hasType(FileChangeType.DELETED);\n    }\n\n    /**\n     * Returns the changes that describe updated files.\n     */\n    getUpdated(): FileChange[] {\n        return this.getOfType(FileChangeType.UPDATED);\n    }\n\n    /**\n     * Returns if this event contains updated files.\n     */\n    gotUpdated(): boolean {\n        return this.hasType(FileChangeType.UPDATED);\n    }\n\n    private getOfType(type: FileChangeType): FileChange[] {\n        return this.changes.filter(change => change.type === type);\n    }\n\n    private hasType(type: FileChangeType): boolean {\n        return this.changes.some(change => change.type === type);\n    }\n}\n\nexport interface BaseStat {\n\n    /**\n     * The unified resource identifier of this file or folder.\n     */\n    resource: URI;\n\n    /**\n     * The name which is the last segment\n     * of the {{path}}.\n     */\n    name: string;\n\n    /**\n     * The size of the file.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    size?: number;\n\n    /**\n     * The last modification date represented as millis from unix epoch.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    mtime?: number;\n\n    /**\n     * The creation date represented as millis from unix epoch.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    ctime?: number;\n\n    /**\n     * A unique identifier that represents the\n     * current state of the file or directory.\n     *\n     * The value may or may not be resolved as\n     * it is optional.\n     */\n    etag?: string;\n}\nexport namespace BaseStat {\n    export function is(arg: Object | undefined): arg is BaseStat {\n        return !!arg && typeof arg === 'object'\n            // eslint-disable-next-line @typescript-eslint/no-explicit-any\n            && ('resource' in arg && <any>arg['resource'] instanceof URI)\n            && ('name' in arg && typeof arg['name'] === 'string');\n    }\n}\n\nexport interface BaseStatWithMetadata extends BaseStat {\n    mtime: number;\n    ctime: number;\n    etag: string;\n    size: number;\n}\n\n/**\n * A file resource with meta information.\n */\nexport interface FileStat extends BaseStat {\n\n    /**\n     * The resource is a file.\n     */\n    isFile: boolean;\n\n    /**\n     * The resource is a directory.\n     */\n    isDirectory: boolean;\n\n    /**\n     * The resource is a symbolic link.\n     */\n    isSymbolicLink: boolean;\n\n    /**\n     * The children of the file stat or undefined if none.\n     */\n    children?: FileStat[];\n}\nexport namespace FileStat {\n    export function is(arg: Object | undefined): arg is BaseStat {\n        return BaseStat.is(arg) &&\n            ('isFile' in arg && typeof arg['isFile'] === 'boolean') &&\n            ('isDirectory' in arg && typeof arg['isDirectory'] === 'boolean') &&\n            ('isSymbolicLink' in arg && typeof arg['isSymbolicLink'] === 'boolean');\n    }\n    export function asFileType(stat: FileStat): FileType {\n        let res = 0;\n        if (stat.isFile) {\n            res += FileType.File;\n\n        } else if (stat.isDirectory) {\n            res += FileType.Directory;\n        }\n        if (stat.isSymbolicLink) {\n            res += FileType.SymbolicLink;\n        }\n        return res;\n    }\n    export function toStat(stat: FileStat): Stat | { type: FileType } & Partial<Stat> {\n        return {\n            type: asFileType(stat),\n            ctime: stat.ctime,\n            mtime: stat.mtime,\n            size: stat.size\n        };\n    }\n    export function fromStat(resource: URI, stat: Stat): FileStatWithMetadata;\n    export function fromStat(resource: URI, stat: { type: FileType } & Partial<Stat>): FileStat;\n    export function fromStat(resource: URI, stat: Stat | { type: FileType } & Partial<Stat>): FileStat {\n        return {\n            resource,\n            name: resource.path.base || resource.path.toString(),\n            isFile: (stat.type & FileType.File) !== 0,\n            isDirectory: (stat.type & FileType.Directory) !== 0,\n            isSymbolicLink: (stat.type & FileType.SymbolicLink) !== 0,\n            mtime: stat.mtime,\n            ctime: stat.ctime,\n            size: stat.size,\n            etag: etag({ mtime: stat.mtime, size: stat.size })\n        };\n    }\n    export function dir(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\n        return fromStat(resource instanceof URI ? resource : new URI(resource), { type: FileType.Directory, ...stat });\n    }\n    export function file(resource: string | URI, stat?: Partial<Omit<Stat, 'type'>>): FileStat {\n        return fromStat(resource instanceof URI ? resource : new URI(resource), { type: FileType.File, ...stat });\n    }\n}\n\nexport interface FileStatWithMetadata extends FileStat, BaseStatWithMetadata {\n    mtime: number;\n    ctime: number;\n    etag: string;\n    size: number;\n    children?: FileStatWithMetadata[];\n}\n\nexport interface ResolveFileResult {\n    stat?: FileStat;\n    success: boolean;\n}\n\nexport interface ResolveFileResultWithMetadata extends ResolveFileResult {\n    stat?: FileStatWithMetadata;\n}\n\nexport interface FileContent extends BaseStatWithMetadata {\n\n    /**\n     * The content of a file as buffer.\n     */\n    value: BinaryBuffer;\n}\n\nexport interface FileStreamContent extends BaseStatWithMetadata {\n\n    /**\n     * The content of a file as stream.\n     */\n    value: BinaryBufferReadableStream;\n}\n\nexport interface WriteFileOptions {\n\n    /**\n     * The last known modification time of the file. This can be used to prevent dirty writes.\n     */\n    readonly mtime?: number;\n\n    /**\n     * The etag of the file. This can be used to prevent dirty writes.\n     */\n    readonly etag?: string;\n}\n\nexport interface ReadFileOptions extends FileReadStreamOptions {\n\n    /**\n     * The optional etag parameter allows to return early from resolving the resource if\n     * the contents on disk match the etag. This prevents accumulated reading of resources\n     * that have been read already with the same etag.\n     * It is the task of the caller to makes sure to handle this error case from the promise.\n     */\n    readonly etag?: string;\n}\n\nexport interface WriteFileOptions {\n\n    /**\n     * The last known modification time of the file. This can be used to prevent dirty writes.\n     */\n    readonly mtime?: number;\n\n    /**\n     * The etag of the file. This can be used to prevent dirty writes.\n     */\n    readonly etag?: string;\n}\n\nexport interface ResolveFileOptions {\n\n    /**\n     * Automatically continue resolving children of a directory until the provided resources\n     * are found.\n     */\n    readonly resolveTo?: readonly URI[];\n\n    /**\n     * Automatically continue resolving children of a directory if the number of children is 1.\n     */\n    readonly resolveSingleChildDescendants?: boolean;\n\n    /**\n     * Will resolve mtime, ctime, size and etag of files if enabled. This can have a negative impact\n     * on performance and thus should only be used when these values are required.\n     */\n    readonly resolveMetadata?: boolean;\n}\n\nexport interface ResolveMetadataFileOptions extends ResolveFileOptions {\n    readonly resolveMetadata: true;\n}\n\nexport interface FileOperationOptions {\n    /**\n     * Indicates that a user action triggered the opening, e.g.\n     * via mouse or keyboard use. Default is true.\n     */\n    fromUserGesture?: boolean\n}\n\nexport interface MoveFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport interface CopyFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport interface CreateFileOptions extends FileOperationOptions, Partial<FileOverwriteOptions> {\n}\n\nexport class FileOperationError extends Error {\n    constructor(message: string, public fileOperationResult: FileOperationResult, public options?: ReadFileOptions & WriteFileOptions & CreateFileOptions) {\n        super(message);\n        Object.setPrototypeOf(this, FileOperationError.prototype);\n    }\n}\n\nexport const enum FileOperationResult {\n    FILE_IS_DIRECTORY,\n    FILE_NOT_FOUND,\n    FILE_NOT_MODIFIED_SINCE,\n    FILE_MODIFIED_SINCE,\n    FILE_MOVE_CONFLICT,\n    FILE_READ_ONLY,\n    FILE_PERMISSION_DENIED,\n    FILE_TOO_LARGE,\n    FILE_INVALID_PATH,\n    FILE_EXCEEDS_MEMORY_LIMIT,\n    FILE_NOT_DIRECTORY,\n    FILE_OTHER_ERROR\n}\n\nexport interface FileOverwriteOptions {\n    /**\n     * Overwrite the file to create if it already exists on disk. Otherwise\n     * an error will be thrown (FILE_MODIFIED_SINCE).\n     */\n    overwrite: boolean;\n}\n\nexport interface FileReadStreamOptions {\n\n    /**\n     * Is an integer specifying where to begin reading from in the file. If position is undefined,\n     * data will be read from the current file position.\n     */\n    readonly position?: number;\n\n    /**\n     * Is an integer specifying how many bytes to read from the file. By default, all bytes\n     * will be read.\n     */\n    readonly length?: number;\n\n    /**\n     * If provided, the size of the file will be checked against the limits.\n     */\n    limits?: {\n        readonly size?: number;\n        readonly memory?: number;\n    };\n}\n\nexport interface FileUpdateOptions {\n    readEncoding: string;\n    writeEncoding: string;\n    overwriteEncoding: boolean;\n}\nexport interface FileUpdateResult extends Stat {\n    encoding: string;\n}\n\nexport interface FileWriteOptions {\n    overwrite: boolean;\n    create: boolean;\n}\n\nexport interface FileOpenOptions {\n    create: boolean;\n}\n\nexport interface FileDeleteOptions {\n    recursive: boolean;\n    useTrash: boolean;\n}\n\nexport enum FileType {\n    Unknown = 0,\n    File = 1,\n    Directory = 2,\n    SymbolicLink = 64\n}\n\nexport interface Stat {\n    type: FileType;\n\n    /**\n     * The last modification date represented as millis from unix epoch.\n     */\n    mtime: number;\n\n    /**\n     * The creation date represented as millis from unix epoch.\n     */\n    ctime: number;\n\n    size: number;\n}\n\nexport interface WatchOptions {\n    recursive: boolean;\n    excludes: string[];\n}\n\nexport const enum FileSystemProviderCapabilities {\n    FileReadWrite = 1 << 1,\n    FileOpenReadWriteClose = 1 << 2,\n    FileReadStream = 1 << 4,\n\n    FileFolderCopy = 1 << 3,\n\n    PathCaseSensitive = 1 << 10,\n    Readonly = 1 << 11,\n\n    Trash = 1 << 12,\n\n    Access = 1 << 24,\n    Update = 1 << 25\n}\n\nexport enum FileSystemProviderErrorCode {\n    FileExists = 'EntryExists',\n    FileNotFound = 'EntryNotFound',\n    FileNotADirectory = 'EntryNotADirectory',\n    FileIsADirectory = 'EntryIsADirectory',\n    FileExceedsMemoryLimit = 'EntryExceedsMemoryLimit',\n    FileTooLarge = 'EntryTooLarge',\n    NoPermissions = 'NoPermissions',\n    Unavailable = 'Unavailable',\n    Unknown = 'Unknown'\n}\n\nexport class FileSystemProviderError extends Error {\n\n    constructor(message: string, public readonly code: FileSystemProviderErrorCode) {\n        super(message);\n        Object.setPrototypeOf(this, FileSystemProviderError.prototype);\n    }\n}\n\nexport function createFileSystemProviderError(error: Error | string, code: FileSystemProviderErrorCode): FileSystemProviderError {\n    const providerError = new FileSystemProviderError(error.toString(), code);\n    markAsFileSystemProviderError(providerError, code);\n\n    return providerError;\n}\n\nexport function ensureFileSystemProviderError(error?: Error): Error {\n    if (!error) {\n        return createFileSystemProviderError('Unknown Error', FileSystemProviderErrorCode.Unknown); // https://github.com/Microsoft/vscode/issues/72798\n    }\n\n    return error;\n}\n\nexport const FileSystemProvider = Symbol('FileSystemProvider');\n/**\n * A {@link FileSystemProvider} provides the capabilities to read, write, discover, and to manage files and folders\n * of the underlying (potentially virtual) file system. {@link FileSystemProvider}s can be used to serve files from both the\n * local disk as well as remote locations like ftp-servers, REST-services etc. A {@link FileSystemProvider} is registered for a certain\n * scheme and can handle all resources whose uri does conform to that scheme.\n */\nexport interface FileSystemProvider {\n\n    /** The {@link FileSystemProviderCapabilities} for this provider. */\n    readonly capabilities: FileSystemProviderCapabilities;\n\n    /** * Event that is fired if the capabilities of this provider have changed. */\n    readonly onDidChangeCapabilities: Event<void>;\n\n    /** Event that is fired if a (watched) file in the filesystem of this provider has changed. */\n    readonly onDidChangeFile: Event<readonly FileChange[]>;\n\n    /** Event that is fired if an error occurred when watching files in the filesystem of this provider. */\n    readonly onFileWatchError: Event<void>;\n\n    /**\n     * Watch the given resource and react to changes by firing the {@link FileSystemProvider#onDidChangeFile} event.\n     * @param resource `URI` of the resource to be watched.\n     * @param opts Options to define if the resource should be watched recursively and to\n     *  provide a set of resources that should be excluded from watching.\n     *\n     * @returns A `Disposable` that can be invoked to stop watching the resource.\n     */\n    watch(resource: URI, opts: WatchOptions): IDisposable;\n\n    /**\n     * Retrieve metadata about a given file.\n     *\n     * @param uri The `URI` of the file to retrieve meta data about.\n     * @returns A promise of the metadata about the resource.\n     */\n    stat(resource: URI): Promise<Stat>;\n\n    /**\n     * Create a new directory using the given resource uri.\n     * @param resource The `URI` of the new folder.\n     */\n    mkdir(resource: URI): Promise<void>;\n\n    /**\n     * Retrieve the content of a given directory.\n     * @param resource The `URI` of the directory.\n     *\n     * @returns A map containing the {@link FileType} for each child resource, identified by name.\n     */\n    readdir(resource: URI): Promise<[string, FileType][]>;\n\n    /**\n     * Delete the given resource.\n     * @param resource The `URI` of the resource to delete.\n     * @param opts Options to define if files should be deleted recursively and if the trash should be used.\n     */\n    delete(resource: URI, opts: FileDeleteOptions): Promise<void>;\n\n    /**\n     * Rename a file or folder.\n     * @param from `URI` of the existing file or folder.\n     * @param to `URI` of the target location.\n     * @param opts Options to define if existing files should be overwritten.\n     */\n    rename(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileFolderCopyCapability}.\n     * See {@link FileSystemProviderWithFileFolderCopyCapability#copy}} for additional documentation.\n     */\n    copy?(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\n     * See {@link FileSystemProviderWithFileReadWriteCapability#readFile} for additional documentation.\n     */\n    readFile?(resource: URI): Promise<Uint8Array>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadWriteCapability}.\n     * See {@link FileSystemProviderWithFileReadWriteCapability#writeFile} for additional documentation.\n     */\n    writeFile?(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithFileReadStreamCapability}.\n     * See {@link FileSystemProviderWithFileReadStreamCapability#readFileStream} for additional documentation.\n     */\n    readFileStream?(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#open} for additional documentation.\n     */\n    open?(resource: URI, opts: FileOpenOptions): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#close} for additional documentation.\n     */\n    close?(fd: number): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#read} for additional documentation.\n     */\n    read?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithOpenReadWriteCloseCapability}.\n     * See {@link FileSystemProviderWithOpenReadWriteCloseCapability#write} for additional documentation.\n     */\n    write?(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\n     * See {@link FileSystemProviderWithAccessCapability#access} for additional documentation.\n     */\n    access?(resource: URI, mode?: number): Promise<void>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithAccessCapability}.\n     * See {@link FileSystemProviderWithAccessCapability#fsPath} for additional documentation.\n     */\n    fsPath?(resource: URI): Promise<string>;\n\n    /**\n     * Optional function that has to be implemented by {@link FileSystemProviderWithUpdateCapability}.\n     * See {@link FileSystemProviderWithUpdateCapability#updateFile} for additional documentation.\n     */\n    updateFile?(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed for providers, that should be\n * able access files, are implemented.\n */\nexport interface FileSystemProviderWithAccessCapability extends FileSystemProvider {\n    /**\n     * Test if the user has the permission to access the given file in the specified mode.\n     * @param resource The `URI` of the file that should be tested.\n     * @param mode The access mode that should be tested.\n     *\n     * @returns A promise that resolves if the user has the required permissions, should be rejected otherwise.\n     */\n    access(resource: URI, mode?: number): Promise<void>;\n\n    /**\n     * Derive the platform specific file system path that is represented by the resource.\n     * @param resource `URI` of the resource to derive the path from.\n     *\n     * @returns A promise of the corresponding file system path.\n     */\n    fsPath(resource: URI): Promise<string>;\n}\n\nexport function hasAccessCapability(provider: FileSystemProvider): provider is FileSystemProviderWithAccessCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Access);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions needed, for providers that should be\n * able to update (text) files, are implemented.\n */\nexport interface FileSystemProviderWithUpdateCapability extends FileSystemProvider {\n    /**\n     * Update the content of the given (text) file according to the given text document changes.\n     * @param resource `URI` of the resource to update.\n     * @param changes Array of events describing the changes to the file.\n     * @param opts The encoding options.\n     *\n     * @returns A promise of the file metadata that resolves after the update process has completed.\n     */\n    updateFile(resource: URI, changes: TextDocumentContentChangeEvent[], opts: FileUpdateOptions): Promise<FileUpdateResult>;\n}\n\nexport function hasUpdateCapability(provider: FileSystemProvider): provider is FileSystemProviderWithUpdateCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.Update);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers\n * that should be able to read & write files, are implemented.\n */\nexport interface FileSystemProviderWithFileReadWriteCapability extends FileSystemProvider {\n    /**\n     * Read the contents of the given file as stream.\n     * @param resource The `URI` of the file.\n     *\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\n     */\n    readFile(resource: URI): Promise<Uint8Array>;\n\n    /**\n     *  Write data to a file, replacing its entire contents.\n     * @param resource The uri of the file.\n     * @param content The new content of the file.\n     * @param opts Options to define if the file should be created if missing and if an existing file should be overwritten.\n     */\n    writeFile(resource: URI, content: Uint8Array, opts: FileWriteOptions): Promise<void>;\n}\n\nexport function hasReadWriteCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadWriteCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadWrite);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to copy\n * file folders, are implemented.\n */\nexport interface FileSystemProviderWithFileFolderCopyCapability extends FileSystemProvider {\n    /**\n     * Copy files or folders.\n     * @param from `URI` of the existing file or folder.\n     * @param to `URI` of the destination location.\n     * @param opts Options to define if existing files should be overwritten.\n     */\n    copy(from: URI, to: URI, opts: FileOverwriteOptions): Promise<void>;\n}\n\nexport function hasFileFolderCopyCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileFolderCopyCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileFolderCopy);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to open,read, write\n * or close files, are implemented.\n */\nexport interface FileSystemProviderWithOpenReadWriteCloseCapability extends FileSystemProvider {\n    /**\n     * Open the give file.\n     * @param resource The `URI` of the file to open.\n     * @param opts Options to define if the file should be created if it does not exist yet.\n     *\n     * @returns A promise of the file descriptor that resolves after the file is open.\n     */\n    open(resource: URI, opts: FileOpenOptions): Promise<number>;\n\n    /**\n     * Close the file with the given file descriptor.\n     * @param fd the file descriptor to close.\n     */\n    close(fd: number): Promise<void>;\n\n    /**\n     * Read specified content from a given file descriptor into a data buffer.\n     * @param fd The file descriptor referencing the file to read from.\n     * @param pos The offset from the beginning of the file from which data should be read.\n     * @param data The buffer that the data will be written to.\n     * @param offset The offset in the buffer at which to start writing.\n     * @param length The number of bytes to read.\n     *\n     * @returns A promise of the number of bytes read.\n     */\n    read(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n\n    /**\n     * Write specified content from the data buffer to the file referenced by the given file descriptor.\n     * @param fd The file descriptor referencing the file to write to.\n     * @param pos The offset from the beginning of the file where this data should be written.\n     * @param offset The part of the buffer to be read from.\n     * @param length The number of bytes to write.\n     *\n     * @returns A promise of the number of bytes written.\n     */\n    write(fd: number, pos: number, data: Uint8Array, offset: number, length: number): Promise<number>;\n}\n\nexport function hasOpenReadWriteCloseCapability(provider: FileSystemProvider): provider is FileSystemProviderWithOpenReadWriteCloseCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileOpenReadWriteClose);\n}\n\n/**\n * Subtype of {@link FileSystemProvider} that ensures that the optional functions, needed for providers that should be able to read\n * files as streams, are implemented.\n */\nexport interface FileSystemProviderWithFileReadStreamCapability extends FileSystemProvider {\n    /**\n     * Read the  contents of the given file as stream.\n     * @param resource The `URI` of the file.\n     *\n     * @return The `ReadableStreamEvents` for the readable stream of the given file.\n     */\n    readFileStream(resource: URI, opts: FileReadStreamOptions, token: CancellationToken): ReadableStreamEvents<Uint8Array>;\n}\n\nexport function hasFileReadStreamCapability(provider: FileSystemProvider): provider is FileSystemProviderWithFileReadStreamCapability {\n    return !!(provider.capabilities & FileSystemProviderCapabilities.FileReadStream);\n}\n\nexport function markAsFileSystemProviderError(error: Error, code: FileSystemProviderErrorCode): Error {\n    error.name = code ? `${code} (FileSystemError)` : 'FileSystemError';\n\n    return error;\n}\n\nexport function toFileSystemProviderErrorCode(error: Error | undefined | null): FileSystemProviderErrorCode {\n\n    // Guard against abuse\n    if (!error) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n\n    // FileSystemProviderError comes with the code\n    if (error instanceof FileSystemProviderError) {\n        return error.code;\n    }\n\n    // Any other error, check for name match by assuming that the error\n    // went through the markAsFileSystemProviderError() method\n    const match = /^(.+) \\(FileSystemError\\)$/.exec(error.name);\n    if (!match) {\n        return FileSystemProviderErrorCode.Unknown;\n    }\n\n    switch (match[1]) {\n        case FileSystemProviderErrorCode.FileExists: return FileSystemProviderErrorCode.FileExists;\n        case FileSystemProviderErrorCode.FileIsADirectory: return FileSystemProviderErrorCode.FileIsADirectory;\n        case FileSystemProviderErrorCode.FileNotADirectory: return FileSystemProviderErrorCode.FileNotADirectory;\n        case FileSystemProviderErrorCode.FileNotFound: return FileSystemProviderErrorCode.FileNotFound;\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit: return FileSystemProviderErrorCode.FileExceedsMemoryLimit;\n        case FileSystemProviderErrorCode.FileTooLarge: return FileSystemProviderErrorCode.FileTooLarge;\n        case FileSystemProviderErrorCode.NoPermissions: return FileSystemProviderErrorCode.NoPermissions;\n        case FileSystemProviderErrorCode.Unavailable: return FileSystemProviderErrorCode.Unavailable;\n    }\n\n    return FileSystemProviderErrorCode.Unknown;\n}\n\nexport function toFileOperationResult(error: Error): FileOperationResult {\n\n    // FileSystemProviderError comes with the result already\n    if (error instanceof FileOperationError) {\n        return error.fileOperationResult;\n    }\n\n    // Otherwise try to find from code\n    switch (toFileSystemProviderErrorCode(error)) {\n        case FileSystemProviderErrorCode.FileNotFound:\n            return FileOperationResult.FILE_NOT_FOUND;\n        case FileSystemProviderErrorCode.FileIsADirectory:\n            return FileOperationResult.FILE_IS_DIRECTORY;\n        case FileSystemProviderErrorCode.FileNotADirectory:\n            return FileOperationResult.FILE_NOT_DIRECTORY;\n        case FileSystemProviderErrorCode.NoPermissions:\n            return FileOperationResult.FILE_PERMISSION_DENIED;\n        case FileSystemProviderErrorCode.FileExists:\n            return FileOperationResult.FILE_MOVE_CONFLICT;\n        case FileSystemProviderErrorCode.FileExceedsMemoryLimit:\n            return FileOperationResult.FILE_EXCEEDS_MEMORY_LIMIT;\n        case FileSystemProviderErrorCode.FileTooLarge:\n            return FileOperationResult.FILE_TOO_LARGE;\n        default:\n            return FileOperationResult.FILE_OTHER_ERROR;\n    }\n}\n\n/**\n * A hint to disable etag checking for reading/writing.\n */\nexport const ETAG_DISABLED = '';\n\nexport function etag(stat: { mtime: number, size: number }): string;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined;\nexport function etag(stat: { mtime: number | undefined, size: number | undefined }): string | undefined {\n    if (typeof stat.size !== 'number' || typeof stat.mtime !== 'number') {\n        return undefined;\n    }\n\n    return stat.mtime.toString(29) + stat.size.toString(31);\n}\n/**\n * Helper to format a raw byte size into a human readable label.\n */\nexport class BinarySize {\n    static readonly KB = 1024;\n    static readonly MB = BinarySize.KB * BinarySize.KB;\n    static readonly GB = BinarySize.MB * BinarySize.KB;\n    static readonly TB = BinarySize.GB * BinarySize.KB;\n\n    static formatSize(size: number): string {\n        if (size < BinarySize.KB) {\n            return size + 'B';\n        }\n        if (size < BinarySize.MB) {\n            return (size / BinarySize.KB).toFixed(2) + 'KB';\n        }\n        if (size < BinarySize.GB) {\n            return (size / BinarySize.MB).toFixed(2) + 'MB';\n        }\n        if (size < BinarySize.TB) {\n            return (size / BinarySize.GB).toFixed(2) + 'GB';\n        }\n        return (size / BinarySize.TB).toFixed(2) + 'TB';\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2018 Ericsson and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n\nimport { FileStat } from '../common/files';\nimport URI from '@theia/core/lib/common/uri';\n\nexport namespace FileSystemUtils {\n\n    /**\n     * Generate unique URI for a given parent which does not collide\n     *\n     * @param parentUri the `URI` of the parent\n     * @param parent the `FileStat` of the parent\n     * @param name the resource name\n     * @param ext the resource extension\n     */\n    export function generateUniqueResourceURI(parentUri: URI, parent: FileStat, name: string, ext: string = ''): URI {\n        const children = !parent.children ? [] : parent.children!.map(child => child.resource);\n\n        let index = 1;\n        let base = name + ext;\n        while (children.some(child => child.path.base === base)) {\n            index = index + 1;\n            base = name + '_' + index + ext;\n        }\n        return parentUri.resolve(base);\n    }\n}\n","/********************************************************************************\n * Copyright (C) 2020 TypeFox and others.\n *\n * This program and the accompanying materials are made available under the\n * terms of the Eclipse Public License v. 2.0 which is available at\n * http://www.eclipse.org/legal/epl-2.0.\n *\n * This Source Code may also be made available under the following Secondary\n * Licenses when the conditions for such availability set forth in the Eclipse\n * Public License v. 2.0 are satisfied: GNU General Public License, version 2\n * with the GNU Classpath Exception which is available at\n * https://www.gnu.org/software/classpath/license.html.\n *\n * SPDX-License-Identifier: EPL-2.0 OR GPL-2.0 WITH Classpath-exception-2.0\n ********************************************************************************/\n/*---------------------------------------------------------------------------------------------\n *  Copyright (c) Microsoft Corporation. All rights reserved.\n *  Licensed under the MIT License. See License.txt in the project root for license information.\n *--------------------------------------------------------------------------------------------*/\n// based on https://github.com/microsoft/vscode/blob/04c36be045a94fee58e5f8992d3e3fd980294a84/src/vs/platform/files/common/io.ts\n\n/* eslint-disable max-len */\n\nimport URI from '@theia/core/lib/common/uri';\nimport { BinaryBuffer } from '@theia/core/lib/common//buffer';\nimport { CancellationToken, cancelled as canceled } from '@theia/core/lib/common/cancellation';\nimport { FileSystemProviderWithOpenReadWriteCloseCapability, FileReadStreamOptions, ensureFileSystemProviderError, createFileSystemProviderError, FileSystemProviderErrorCode } from './files';\nimport { WriteableStream, ErrorTransformer, DataTransformer } from '@theia/core/lib/common/stream';\n\nexport interface CreateReadStreamOptions extends FileReadStreamOptions {\n\n    /**\n     * The size of the buffer to use before sending to the stream.\n     */\n    bufferSize: number;\n\n    /**\n     * Allows to massage any possibly error that happens during reading.\n     */\n    errorTransformer?: ErrorTransformer;\n}\n\n/**\n * A helper to read a file from a provider with open/read/close capability into a stream.\n */\nexport async function readFileIntoStream<T>(\n    provider: FileSystemProviderWithOpenReadWriteCloseCapability,\n    resource: URI,\n    target: WriteableStream<T>,\n    transformer: DataTransformer<BinaryBuffer, T>,\n    options: CreateReadStreamOptions,\n    token: CancellationToken\n): Promise<void> {\n    let error: Error | undefined = undefined;\n\n    try {\n        await doReadFileIntoStream(provider, resource, target, transformer, options, token);\n    } catch (err) {\n        error = err;\n    } finally {\n        if (error && options.errorTransformer) {\n            error = options.errorTransformer(error);\n        }\n\n        target.end(error);\n    }\n}\n\nasync function doReadFileIntoStream<T>(provider: FileSystemProviderWithOpenReadWriteCloseCapability, resource: URI, target: WriteableStream<T>, transformer: DataTransformer<BinaryBuffer, T>, options: CreateReadStreamOptions, token: CancellationToken): Promise<void> {\n\n    // Check for cancellation\n    throwIfCancelled(token);\n\n    // open handle through provider\n    const handle = await provider.open(resource, { create: false });\n\n    // Check for cancellation\n    throwIfCancelled(token);\n\n    try {\n        let totalBytesRead = 0;\n        let bytesRead = 0;\n        let allowedRemainingBytes = (options && typeof options.length === 'number') ? options.length : undefined;\n\n        let buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n        let posInFile = options && typeof options.position === 'number' ? options.position : 0;\n        let posInBuffer = 0;\n        do {\n            // read from source (handle) at current position (pos) into buffer (buffer) at\n            // buffer position (posInBuffer) up to the size of the buffer (buffer.byteLength).\n            bytesRead = await provider.read(handle, posInFile, buffer.buffer, posInBuffer, buffer.byteLength - posInBuffer);\n\n            posInFile += bytesRead;\n            posInBuffer += bytesRead;\n            totalBytesRead += bytesRead;\n\n            if (typeof allowedRemainingBytes === 'number') {\n                allowedRemainingBytes -= bytesRead;\n            }\n\n            // when buffer full, create a new one and emit it through stream\n            if (posInBuffer === buffer.byteLength) {\n                await target.write(transformer(buffer));\n\n                buffer = BinaryBuffer.alloc(Math.min(options.bufferSize, typeof allowedRemainingBytes === 'number' ? allowedRemainingBytes : options.bufferSize));\n\n                posInBuffer = 0;\n            }\n        } while (bytesRead > 0 && (typeof allowedRemainingBytes !== 'number' || allowedRemainingBytes > 0) && throwIfCancelled(token) && throwIfTooLarge(totalBytesRead, options));\n\n        // wrap up with last buffer (also respect maxBytes if provided)\n        if (posInBuffer > 0) {\n            let lastChunkLength = posInBuffer;\n            if (typeof allowedRemainingBytes === 'number') {\n                lastChunkLength = Math.min(posInBuffer, allowedRemainingBytes);\n            }\n\n            target.write(transformer(buffer.slice(0, lastChunkLength)));\n        }\n    } catch (error) {\n        throw ensureFileSystemProviderError(error);\n    } finally {\n        await provider.close(handle);\n    }\n}\n\nfunction throwIfCancelled(token: CancellationToken): boolean {\n    if (token.isCancellationRequested) {\n        throw canceled();\n    }\n\n    return true;\n}\n\nfunction throwIfTooLarge(totalBytesRead: number, options: CreateReadStreamOptions): boolean {\n\n    // Return early if file is too large to load and we have configured limits\n    if (options?.limits) {\n        if (typeof options.limits.memory === 'number' && totalBytesRead > options.limits.memory) {\n            throw createFileSystemProviderError('To open a file of this size, you need to restart and allow it to use more memory', FileSystemProviderErrorCode.FileExceedsMemoryLimit);\n        }\n\n        if (typeof options.limits.size === 'number' && totalBytesRead > options.limits.size) {\n            throw createFileSystemProviderError('File is too large to open', FileSystemProviderErrorCode.FileTooLarge);\n        }\n    }\n\n    return true;\n}\n"],"sourceRoot":""}